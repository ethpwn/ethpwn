# Global State

`ethpwn` maintains a variety of global state across runs to allow the interaction scripts to focus only on the logic of the interaction, and not on the boilerplate of setting up the environment.

Specifically, `ethpwn` maintains the following concepts in a global state: global configuration (e.g., wallets info), compiled contract metadata, and deployed contract instances.

## üìù Configuration

| ‚ùóÔ∏è Note                                                              |
|----------------------------------------------------------------------|
| To start out, if you haven't created your global config before, you can run `ethpwn config create` to generate your initial configuration file. This command will interactively prompt you for the most important settings, including the Ethereum node URL to use, and the setup/import your wallets. |

The configuration for `ethpwn` is located at `~/.config/ethpwn/config.json`. This file allows you to configure a variety of settings globally, which are then used by the various modules to simplify the interaction process.

You can use the `ethpwn config` and `ethpwn wallet` commands to modify the most common configuration settings, or you can edit the file directly.

The most important settings are the following:

1. `default_network`: the default network to use for all interactions
2. `default_node_urls`: default Ethereum node URLs for each network which can be used to retrieve blockchain information state
3. `wallets`: Ethereum wallets to use to interact with the different blockchain networks
4. `etherscan_api_key`: API key for etherscan, which can be used to retrieve verified source code for contracts
5. `debugger configuration`: customizations for `ethdbg`. See [ethdbg](/ethpwn/ethdbg/usage/).

The configuration is structured as follows and is shared between `ethdbg` and `ethpwn`:

```json
{
  "default_network": "mainnet",
  "default_node_urls": {
    "mainnet": "<YOUR_ETHEREUM_NODE_URL>",
  },
  "credentials": {
    "etherscan": "<OPTIONAL_ETHERSCAN_API>"
  },
  "dbg": {
  }
}
```

This other configuration file is located at `~/.config/ethpwn/wallets.json` and contains the configuration for the accounts that you want to use when using `ethpwn`.

An example of such a configuration is the following:

```json
[
{"address": "0x1a5984F43dAD95a5121b1b30B9190d619d84d21C",
"private_key": "0x2838aa1e473a046941d3ee4481396b9c54c944a6b6321e489b654554125f374b",
"network": "mainnet",
"name": "my-test-wallet",
"description": "Default wallet generated by ethpwn on 2023-07-09 13:12:05.184774"}
]
```

| üõë Warning                               |
|------------------------------------------|
| ***!!!!! DO NOT use accounts and private keys that hold valuable assets in this config file! This file is NOT protected in any way. Putting sensitive private keys here might lead to exposing them in the clear and can cause the loss of funds on the related account if someone can steal them. ALWAYS use test accounts!***|

## üìö ContractRegistry
The contract registry is your personal library of smart contracts.
Specifically, whenever you compile and deploy a smart contract yourself, or, you interact with a verified contract on-chain (if you have a valid Etherscan API configured), `ethpwn` will store the address of the contract and its corresponding metadata in a global `ContractRegistry` object, which can be accessed via `contract_registry()`.

The contract registry is stored locally on your machine in `~/.config/ethpwn/contract_registry/` by default and will be loaded every time you use `ethpwn`.

The example in the [tutorial](#tutorial) below illustrates this by retrieving a contract instance for the UniswapRouter contract from the contract registry, and then using it to interact with the contract without having to specify the address, ABI, storage layout, or source code of the contract.

### ‚úÖ Etherscan Verified Source Code
As mentioned earlier, `ethpwn` can fetch available verified source code for contracts from Etherscan if you have a working API key. 
This allows you to transparently retrieve the metadata for these contracts without needing to explicitly compile them yourself. The target contract is automatically compiled and added to the contract registry for you.

To use this feature, set the `ETHERSCAN_API_KEY` environment variable to your etherscan API key, or add it to your `ethpwn` configuration file.

Then you can use the following command to fetch the verified source code for the Uniswap Router contract:
```bash
ethpwn contract fetch_verified_source 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D
```

Or, in a Python script, you can do the following:
```python
from ethpwn import *

# either specify the API key in the environment
instance = fetch_verified_contract_source(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D)

# or specify it explicitly
instance = fetch_verified_contract_source(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, api_key='<YOUR_API_KEY>')
```

## ü™™ ContractMetadata
Whenever you compile contracts within a Python script, `ethpwn` manages the compiled contract metadata in a *temporay*  `ContractMetadata` object that can be accessed via the `CONTRACT_METADATA` variable.

Note that, this object does NOT persists after the termination of your script.
Instead, we store the corresponding `ContractMetadata` object only you record a contract in the `contract_registry` (in this case the contract being deployed is unambiguous).

The contract metadata contains, among other things, the following information:

- `metadata.compiler` - the compiler used to compile the contract
- `metadata.sources` - the sources used to compile the contract
- `metadata.source_file` - the source file the current contract is found in
- `metadata.contract_name` - the name of the contract
- `metadata.bin_runtime` - the bytecode of the contract deployed on the blockchain
- `metadata.srcmap_runtime` - the source map of the deployed contract
- `metadata.abi` - the ABI of the contract, used to interact with the contract
- `metadata.storage_layout` - the storage layout of the contract, used to display and retrieve storage variables in `ethdbg`

It also provides various helper functions to manipulate or analyze instances of this contract, e.g.

```python
  def source_info_for_pc(self, pc, fork='paris') -> InstructionSourceInfo:
    '''
    Returns the source info for the instruction at the given program counter in the deployed bytecode.
    '''

  def deploy(self, *constructor_args, **tx_extras) -> Tuple[HexBytes, Contract]:
    '''
    Deploys an instance of this contract to the blockchain and registers it with the contract registry.
    '''

  def get_contract_at(self, addr) -> Contract:
    '''
    Returns a web3 contract instance for the contract at the given address. This will
    automatically register this contract instance with the contract registry.
    '''

  def decode_function_input(self, data):
    '''
    Decodes the function input data for a contract of this class. Returns a tuple of the
    function name and a dictionary of the arguments.
    '''
```

In the current session you can retrieve contracts by name, e.g., if you have previously compiled the code of the uniswap router contract, you can use `CONTRACT_METADATA['UniswapV2Router02']` to retrieve the `ContractMetadata` for this contract.

You can also retrieve the `ContractMetadata` for a contract that is stored in the `contract_registry` by using `contract_registry().get(<contract_address>).metadata`.

## üê• Tutorials

Here a few ways in which you can leverage the global states used and exported by `ethpwn` in your scripts:

```bash
##########

# set up names for the contracts we want to use for easy access
ethpwn contract name add 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D UniswapV2Router02
ethpwn contract name add 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 WETH
ethpwn contract name add 0x6B175474E89094C44Da98b954EedeAC495271d0F DAI

# fetch the verified source code for the uniswap router contract from etherscan to access its metadata and ABI
ethpwn contract fetch_verified_source 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D
```

## Direct Interaction in `ethpwn` Scripts

Then, we can use the uniswap router contract in our scripts to interact with it.
```python
from ethpwn import *

# get the contract instance for the uniswap router contract at address 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D

MY_addr = 0x1234567890123456789012345678901234567890
deadline = int(time.time()) + 30 * 60 # 30 minutes at most

# fetch the Contract instance for the uniswap router contract
# this automatically retrieves the ABI, source code, and storage layout for the contract
uniswap_router = contract_registry().get(contract_by_name('UniswapV2Router02'))

transact(
    # this uses the automatic abi to encode the function call
    uniswap_router.w3().swapExactETHForTokens(
        100,                    # amountOutMin
        [contract_by_name('WETH'), contract_by_name('DAI')],  # path
        my_addr,                # to
        deadline                # deadline
    ),
    value=1 * ETHER
)
```

## Integration in contract deployment

Instead of performing this action manually, we can also deploy a solidity contract to perform this action for us.

```python
from ethpwn import *

solidity_source = """
pragma solidity ^0.6.0;

interface IUniswapV2Router02 {
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
}

contract Swapper {
    IUniswapV2Router02 uniswap_router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    address WETH_addr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address DAI_addr = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address my_addr = 0x1234567890123456789012345678901234567890;
    uint deadline = block.timestamp + 30 * 60; // 30 minutes at most

    function getDAI(uint amountOutMin) public payable {
        uniswap_router.swapExactETHForTokens{value: msg.value}(
            amountOutMin,
            [WETH_addr, DAI_addr],
            my_addr,
            deadline
        );
    }
}
"""

# compile the contract
contract_metadata = CONTRACT_METADATA.compile_solidity_source(solidity_source, 'Swapper.sol')

# deploy the contract
contract_instance = contract_metadata.deploy()

# call the contract's `getDAI` function
txid, *_ = transact(contract_instance.w3.getDAI(100), value=1 * ETHER)
print(f"Transaction ID: {txid.hex()}")
```

Additionally, we can use `ethdbg` to debug any transactions interacting with the contract instance we just deployed.
Thanks to the contract registry, `ethdbg` will automatically have the contract metadata available during the debug sessions
and display both the source code information and the storage layout for the contract.

If we registered the UniswapV2Router02 contract with the registry as the previous example did, `ethdbg` will display
the source code and storage information for that contract as well.
```bash
# ensure the debug information for UniswapV2Router02 is available
ethpwn contract fetch_verified_source 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D

# launch ethdbg to debug the transaction, this should display the source code and storage layout for both contracts
ethdbg --txid <id of the transaction we just attempted>
```