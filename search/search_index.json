{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\u2666 ethpwn - the Swiss Army Knife for Smart Contracts Hacking","text":"<p><code>ethpwn</code> is a project inspired by the widely popular CTF exploitation framework <code>pwntools</code>, and the amazing enhanced GDB utility <code>GEF</code> by @hugsy. In other words, <code>ethpwn</code> is all you ever wanted for debugging and interacting with smart contracts on EVM-based blockchains.</p> <p>The project started due to the frustration of @honululu, @degrigis and @robmcl4, when trying to debug exploits for the ethernaut challenges. With <code>ethpwn</code>, we hope to improve educational capabilities when it comes to smart contract and blockchain analysis, and facilitate research efforts in the area.</p> <p>Currently, <code>ethpwn</code> is a package that ships a set of handy wrappers for the <code>web3</code> Python package (in pwntools style!), and a CLI debugger --<code>ethdbg</code>-- that allows users to set breakpoints, inspect memory, storage (and more!) in a GDB-like interface. It even automatically pulls verified source-code from Etherscan if it can find it!</p> <p><code>ethpwn</code> requires Python3.</p> <p></p>  \u26a0\ufe0f WARNING \u26a0\ufe0f                              <code>ethpwn</code> is optimized for ease-of-use. e.g., we aggressively over-allocate the gas price for transactions to ensure that they are mined quickly. This decision works well for CTF challenges, but can be a problem if you are using <code>ethpwn</code> to interact with real contracts on the mainnet (i.e., it can cause a massive overpay in terms of transaction fee). DO NOT USE <code>ethpwn</code> TO INTERACT WITH REAL CONTRACTS ON THE MAINNET UNLESS YOU ARE ABSOLUTELY SURE WHAT YOU ARE DOING."},{"location":"#quick-start","title":"\u26a1\ufe0f Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<p>To start with <code>ethpwn</code>, you only need Python3, we will take care of the rest.</p> <p>You can verify your Python version with:</p> <pre><code>hacker@eth:~$ python3 --version\nPython 3.8.10\n</code></pre> <p>We strongly suggest that you create a Python3 virtual environment before proceeding.</p> <p>Once you have done that, just:</p> <pre><code>pip install ethpwn\n</code></pre>"},{"location":"#developer-installation","title":"Developer Installation","text":"<p>If you want to install <code>ethpwn</code> in development mode (i.e., editable in the current folder), first: Make sure you have the latest version of <code>pip</code>:</p> <pre><code>hacker@eth:~$ pip --version\npip 23.1.2\n</code></pre> <p>Then, just:</p> <pre><code>git clone git@github.com:ethpwn/ethpwn.git &amp;&amp; pip install -e ./ethpwn/\n</code></pre> \u2757\ufe0f Note To start out, if you haven't created your global config before, you should run <code>ethpwn config create</code> to generate your initial configuration file. This command will interactively prompt you for the most important settings, including the Ethereum node URL to use and wallets you want to use."},{"location":"#rpc-node","title":"RPC Node","text":"<p>You will need access to an Ethereum RPC node to retrieve information about the blockchain, and to interact with smart contracts.</p>"},{"location":"#custom-rpc-node","title":"Custom RPC node","text":"<p>If you have your own node, just grab the RPC endpoint address and you are good to go. The link you will get is something like: <code>ws://192.168.1.1:8546</code>.</p>"},{"location":"#public-rpc-node","title":"Public RPC node","text":"<p>If you do not have an Ethereum node, or you simply do not want to use your own, you can easily get access to a public one by using a service like Infura or Alchemy. These providers offer a free tier for accessing the RPC nodes of many different blockchains (e.g., Ethereum, Sepolia, Avalanche) which is sufficient for our purposes.</p> <p>The link you will get should look something like: <code>https://mainnet.infura.io/v3/38eb4be006004da4a89315232040e222</code>.</p> \u26a0\ufe0f Warning While these providers offer public nodes access, the RPC URL is generated per-user. DO NOT publish the obtained URL on the internet or people will start to make requests using your account and you will quickly run out of queries. The free tier is rate-limited, but it should be more than enough for using <code>ethpwn</code> in a normal work-day."},{"location":"#run","title":"\ud83d\ude80 Run","text":"<p>To try out <code>ethdbg</code>, a simple way of debugging a transaction that happened on the Ethereum mainnet is:</p> <pre><code>ethdbg --txid 0x82a11757c3f34c2882e209c6e5ae96aff3e4db7f7984d54f92b02e1fed87e834 --node-url https://mainnet.infura.io/v3/38eb4be006004da4a89315232040e222\n</code></pre> <p>To learn more about the debugging features available in <code>ethdbg</code>, and all the functionalities offered by <code>ethpwn</code>, please refer to their respective pages.</p>"},{"location":"#bugs-feedbacks","title":"\ud83d\udc1b Bugs &amp; Feedbacks","text":"<p>For any bugs and feedback please either open an issue on our Github repository, or, even better, a pull request! Please keep in mind this is a tool developed for fun in our spare time, while we will try to maintain it, we currently cannot commit to regular releases and bug fixes.</p>"},{"location":"#contributions","title":"\ud83d\udee0\ufe0f Contributions","text":"<p><code>ethpwn</code> is currently mainly maintained by degrigis, honululu, robmcl4 and the following contributors:</p> <p></p>"},{"location":"chains/","title":"\u26d3\ufe0f chains support","text":"<p><code>ethpwn</code> currently has a backend that can only support EVM-based chains.</p> <p>Currently we support the following ones:</p> Chain Name Chain Id Supported mainnet 1 \u2705 sepolia (testnet) 11155111 \u2705"},{"location":"faq/","title":"\uff1fFAQ","text":""},{"location":"faq/#are-transactions-sent-to-the-real-network","title":"Are transactions sent to the real network?","text":"<p>When debugging a transaction with <code>ethdbg</code> everything is emulated locally and nothing is sent to the actual blockchain. The connection to the chain RPC node is needed to pull different information related to the transaction for debugging.</p> <p>On the other hand, when using <code>ethpwn</code>, the library connects to the target blockchain and it is able to perform operations on it. While you can use Sepolia ETH to perform your tests, always be careful NOT to use important accounts with actual valuable funds when using <code>ethpwn</code>, for example, because the configuration stores them in plaintext in the config files.</p>"},{"location":"faq/#are-you-gonna-support-other-evm-based-chain","title":"Are you gonna support other EVM-based chain?","text":"<p>While <code>ethpwn</code> can support other EVM-based blockchains, currently we do not have the manpower to maintain other chains. We will rely on the community to further expand <code>ethpwn</code> in this direction if this is desired.</p>"},{"location":"faq/#are-you-gonna-support-non-evm-based-chain","title":"Are you gonna support non-EVM-based chain?","text":"<p><code>ethpwn</code> uses <code>py-evm</code> as its execution backend, hence, any non-EVM-based blockchain is currently out of scope.</p>"},{"location":"faq/#how-can-i-contribute","title":"How can I contribute?","text":"<p>See our TODO, we are happy to accept pull requests for those and other features! If you have anything else in mind just reach out on our Github page, or on twitter @degrigis, @honululu.</p>"},{"location":"ethdbg/","title":"Installing ethdbg","text":""},{"location":"ethdbg/commands/","title":"Commands","text":""},{"location":"ethdbg/showroom/","title":"Showroom","text":"<p>Here a few interesting debugging sessions done with <code>ethdbg</code> (will add more in the future).</p>"},{"location":"ethdbg/showroom/#debugging-polynetwork-hack","title":"\ud83c\udfaa Debugging Polynetwork hack","text":""},{"location":"ethdbg/usage/","title":"Usage","text":"<p><code>ethdbg</code> is the CLI EVM debugger installed with the <code>ethpwn</code> package. Before starting to play with <code>ethdbg</code> you need to make a few steps.</p>"},{"location":"ethdbg/usage/#config-file","title":"\ud83d\udcdd Config File","text":"<p>There are two main configuration files that can be used to customize the behavior of <code>ethdbg</code>.</p>"},{"location":"ethdbg/usage/#configjson","title":"\u2666\ufe0f config.json","text":"<p>The <code>ethpwn</code> config file is located at <code>~/.config/ethpwn/config.json</code> and includes configuration for  the behavior of <code>ethdbg</code> while debugging.</p> <p>Refer to the ethpwn configuration docs for the general structure of the configuration file.</p> <p>If you did not do so already, you can create a configuration file by running:</p> <pre><code>ethpwn config create\n</code></pre> <p>Under the key <code>dbg</code> in the main configuration, the following options are available:</p> Option String Option Summary Default <code>show_opcodes_desc</code> whether to display the description of the EVM opcodes in the disassembly True <code>stop_on_returns</code> whether you want <code>ethdbg</code> to always stop at RETURN opcodes False <code>stop_on_reverts</code> whether you want <code>ethdbg</code> to always stop at REVERT opcodes True <code>hide_sstores</code> whether you want to hide the sstores issued for the current account in the context view False <code>hide_sloads</code> whether you want to hide the sloads issued for the current account in the context view False <code>context_layout</code> The layout of the views to display in the context, for details see Context Layout \"source,metadata,status,disass,stack,callstack\" <code>source_view_cutoff</code> the maximum amount of source code lines that are displayed None <p>Here are two possible configuration files:</p> <pre><code>{\n  \"default_network\": \"mainnet\",\n  \"default_node_urls\": {\n    \"mainnet\": \"&lt;YOUR_INFURA_MAINNET_RPC_URL&gt;\",\n  },\n  \"credentials\": {\n    \"etherscan\": \"&lt;OPTIONAL_ETHERSCAN_API&gt;\"\n  },\n  \"dbg\": {\n    \"show_opcodes_desc\": false,\n    \"stop_on_returns\": false,\n    \"stop_on_reverts\": true,\n    \"hide_sstores\": true,\n    \"hide_sloads\": true,\n    \"hide_source_view\": false,\n    \"source_view_cutoff\": 20\n  }\n}\n</code></pre> <pre><code>{\n  \"default_network\": \"mainnet\",\n  \"default_node_urls\": {\n    \"mainnet\": \"&lt;YOUR_INFURA_MAINNET_RPC_URL&gt;\",\n    \"sepolia\": \"&lt;YOUR_INFURA_SEPOLIA_RPC_URL&gt;\",\n  },\n  \"credentials\": {\n    \"etherscan\": \"&lt;OPTIONAL_ETHERSCAN_API&gt;\"\n  },\n  \"dbg\": {\n    \"hide_sloads\": true,\n    \"source_view_cutoff\": 20\n  }\n}\n</code></pre>"},{"location":"ethdbg/usage/#walletsjson","title":"\u2666\ufe0f wallets.json","text":"<p>This file is located at <code>~/.config/ethpwn/wallets.json</code> and contains the configuration for the accounts that you want to use when debugging transactions with <code>ethdbg</code>. An example of such a configuration is the following:</p> <pre><code>[\n{\"address\": \"0x1a5984F43dAD95a5121b1b30B9190d619d84d21C\",\n\"private_key\": \"0x2838aa1e473a046941d3ee4481396b9c54c944a6b6321e489b654554125f374b\",\n\"network\": \"mainnet\",\n\"name\": \"my-test-wallet\",\n\"description\": \"Default wallet generated by ethpwn on 2023-07-09 13:12:05.184774\"}\n]\n</code></pre> \ud83d\uded1 Warning !!!!! DO NOT use accounts and private keys that hold valuable assets in this config file! This file is NOT protected in any way. Putting sensitive private keys here might lead to exposing them in the clear and can cause the loss of funds on the related account if someone can steal them. ALWAYS use test accounts! <p><code>ethdbg</code> will generate a default wallet with a random account if you do not specify one and will use it for signing transactions. Conversely, if you have multiple accounts such as:</p> <pre><code>[\n{\"address\": \"0x1a5984F43dAD95a5121b1b30B9190d619d84d21C\",\n\"private_key\": \"0x2838aa1e473a046941d3ee4481396b9c54c944a6b6321e489b654554125f374b\",\n\"network\": \"mainnet\",\n\"name\": \"my-test-wallet\",\n\"description\": \"Default wallet generated by ethpwn on 2023-07-09 13:12:05.184774\"},\n\n{\"address\": \"0x2c076bc7090686fad57814965D53722CFC3e0B13\",\n\"private_key\": \"0x51f300465cba08ec2a83d58223824a5b7902c76d64920a5ad90b5bcfd24c6565\",\n\"network\": \"sepolia\",\n\"name\": \"my-sepolia-wallet\",\n\"description\": \"Default wallet generated by ethpwn on 2023-07-15 10:49:19.516119\"}\n]\n</code></pre> <p>You can select the wallet you want to use by using the <code>--wallet</code> command line option and the \"name\" of the wallet. e.g.:</p> <pre><code>ethdbg --target 0xeC55Bf7E10b6594874554BAd1B461214Cab413d4 --calldata cbd8c06a00000000000000 --node-url \"&lt;YOUR_INFURA_MAINNET_RPC_URL&gt;\" --block 11469711 --wallet my-sepolia-wallet\n</code></pre>"},{"location":"ethdbg/usage/#command-line-arguments","title":"\u26a1\ufe0f Command Line Arguments","text":"<p><code>ethdbg</code> supports different command line arguments that can customize your analysis.</p> <p>The following options can be used, for instance, to simulate sending a new transaction to a <code>target</code> smart contract with custom <code>calldata</code>, or, replaying a given transaction (<code>txid</code>) with a different <code>sender</code> and more!</p> Option String Required Default Option Summary --txid False None Instantiate ethdbg to replay an existing transaction. --full-context False False Given a transaction <code>T</code> that you want to replay, whether or not you want to apply the transactions preceding <code>T</code> in the block (i.e., if the execution depends on the execution of the previous ones!). --sender False The original sender in the transaction (if <code>txid</code> is specified), otherwise, the sender in your wallet.json Allows you to set or overwrite the address of the sender in the debugged transaction. --gas False The original gas used for  the transaction (if <code>txid</code> is specified), otherwise, estimated by <code>ethdbg</code> Allows you to set or overwrite the gas used for the debugged transaction. --balance False Balance of the original sender in the transaction (if <code>txid</code> is specified), otherwise, a placeholder value of 100000000 ETH. Overwrite or set the balance of the sender wallet of the target transaction. --node-url False Value in the ethdbg_config file, or, <code>127.0.0.1:8546</code>. URL of the RPC node you want to use. --target False The original contract address (if <code>txid</code> is specified) Target smart contract address when trying to send a new transaction. --block False The original block (if <code>txid</code> is specified), otherwise the <code>latest</code> block. Block at which you want to simulate the new transaction (the transaction will be simulated as executing at the beginning of the block). --calldata False The original calldata of the transaction (if <code>txid</code> is specified) Calldata you want to use for a new transaction --wallet False The default wallet in the <code>ethpwn</code> config Name or address of the wallet in the configuration you want to use --shellcode False None EVM bytecode that we want to execute on-the-fly in ethdbg --value False None The original value sent with the transaction (if <code>txid</code> is specified), otherwise 0"},{"location":"ethdbg/usage/#examples-usage","title":"\ud83d\ude80 Examples Usage","text":""},{"location":"ethdbg/usage/#replay-an-existing-transaction-on-chain-as-is","title":"\u2666\ufe0f Replay an existing transaction on-chain as-is.","text":"<pre><code>ethdbg --txid 0x168f7f3acd40e0632e11b208c40ecc3c790bcb46c131f0207892859871ec3d3e\n</code></pre>"},{"location":"ethdbg/usage/#replay-an-existing-transaction-on-chain-as-is-with-full-context","title":"\u2666\ufe0f Replay an existing transaction on-chain as-is, with full context.","text":"<pre><code>ethdbg --full-context --txid 0x168f7f3acd40e0632e11b208c40ecc3c790bcb46c131f0207892859871ec3d3e\n</code></pre>"},{"location":"ethdbg/usage/#replay-an-existing-transaction-on-chain-and-change-the-sender","title":"\u2666\ufe0f Replay an existing transaction on-chain and change the sender.","text":"<pre><code>ethdbg --sender 0x1a5984F43dAD95a5121b1b30B9190d619d84d21C --txid 0x168f7f3acd40e0632e11b208c40ecc3c790bcb46c131f0207892859871ec3d3e\n</code></pre> \u2757\ufe0f Note The chosen sender must have enough funds to execute the transaction. You can use <code>--balance</code> to edit this value. <pre><code>ethdbg --balance 1000000000000000 --sender 0x1a5984F43dAD95a5121b1b30B9190d619d84d21C --txid 0x168f7f3acd40e0632e11b208c40ecc3c790bcb46c131f0207892859871ec3d3e\n</code></pre>"},{"location":"ethdbg/usage/#replay-an-existing-transaction-at-a-different-block","title":"\u2666\ufe0f Replay an existing transaction at a different block.","text":"<pre><code>ethdbg --block 17700180 --txid 0x168f7f3acd40e0632e11b208c40ecc3c790bcb46c131f0207892859871ec3d3e\n</code></pre>"},{"location":"ethdbg/usage/#send-a-new-transaction-to-target-contract-with-custom-calldata","title":"\u2666\ufe0f Send a new transaction to target contract with custom calldata.","text":"<pre><code>ethdbg --calldata cbd8c06a00000000000000 --target 0xeC55Bf7E10b6594874554BAd1B461214Cab413d4\n</code></pre>"},{"location":"ethdbg/usage/#send-a-new-transaction-to-target-contract-with-custom-calldata-at-custom-block","title":"\u2666\ufe0f Send a new transaction to target contract with custom calldata at custom block.","text":"<pre><code>ethdbg --block 11469711 --calldata cbd8c06a00000000000000 --target 0xeC55Bf7E10b6594874554BAd1B461214Cab413d4\n</code></pre>"},{"location":"ethdbg/commands/break/","title":"break","text":"<p>The command <code>break</code> works similarly to a GDB breakpoint.</p> <p>A breakpoint in <code>ethdbg</code> can be <code>simple</code> or <code>conditional</code>.</p>"},{"location":"ethdbg/commands/break/#simple-breakpoint","title":"\ud83d\udca5 Simple Breakpoint","text":"<p>A simple breakpoint can be placed on a specific value of the <code>&lt;PC&gt;</code> or at a specific <code>&lt;OPCODE&gt;</code></p> <p>Syntax:</p> <ul> <li><code>break &lt;PC&gt;</code></li> <li><code>break &lt;OPCODE&gt;</code></li> </ul> <p> </p> \u2757\ufe0f Note Make sure the chosen OPCODE is available in the EVM version currently executing the transaction."},{"location":"ethdbg/commands/break/#conditional-breakpoint","title":"\ud83d\udca5 Conditional Breakpoint","text":"<p>The expressiveness of a conditional breakpoint is currently still limited, but they already support some interesting combination of events.</p> <p>A conditional breakpoint is set by specifying a tuple of the form <code>&lt;what&gt;&lt;when&gt;&lt;value&gt;</code>. Multiple <code>&lt;what&gt;&lt;when&gt;&lt;value&gt;</code> tuples create more complex stop conditions that must all be satisfied for the breakpoint to trigger (AND).</p> <p>Syntax:  <code>break &lt;what&gt;&lt;when&gt;&lt;value&gt;,&lt;what&gt;&lt;when&gt;&lt;value&gt;,...</code></p> <p>Currently we support the following <code>&lt;what&gt;</code> and <code>&lt;when&gt;</code>:</p> What Description <code>pc</code> Value of the program counter to break at <code>op</code> OPCODE at which to stop <code>addr</code> Contract address currently executing code <code>saddr</code> Contract address which currently backs the storage <code>value</code> stop when a particular amount of ETH is sent as part of a CALL <code>gas_remaining</code> stop when a specific value of gas is remaining \u2757\ufe0f Note Note how <code>addr</code> and <code>saddr</code> represent different addresses. <code>addr</code> is the code address, i.e., the address of the smart contract currently executing. On the other hand, <code>saddr</code> is the storage address, i.e., the address of the contract whose storage will be modified when storage operations occur. For more information on the distinction, see the difference between the CALL and DELEGATECALL instructions. When Description <code>[= or ==]</code> Equality <code>!=</code> NOT equality <code>[&gt; or &gt;=]</code> Greater than/Greater or Equal then <code>[&lt; or &lt;=]</code> Lower than/Lower or Equal then <p>For instance, one can set a breakpoint which only triggers when the OPCODE is an <code>SSTORE</code> that operates on the storage of a specific contract address by doing:</p> <pre><code>break op=SSTORE,saddr=0x5a51E2ebF8D136926b9cA7b59B60464E7C44d2Eb\n</code></pre> <p></p>"},{"location":"ethdbg/commands/calldata/","title":"calldata","text":"<p>Print the calldata sent to the current executing contract. A specific portion of the calldata can be printed by specifying the <code>&lt;offset&gt;</code> and the <code>&lt;length&gt;</code></p> <p>Usage: <code>calldata &lt;offset&gt; &lt;length&gt;</code></p> <p></p>"},{"location":"ethdbg/commands/callhistory/","title":"callhistory","text":"<p>Display the history of all the calls performed during the execution of the transaction in a tree-like view.</p> <p>Syntax: <code>callhistory</code></p> <p></p>"},{"location":"ethdbg/commands/context/","title":"context","text":"<p>Print the current context of the EVM.</p> <p>Syntax: <code>context</code></p> <p></p> <p>The context is divided into different views that provide different kinds of information during debugging.</p> <p>The layout of the context view is fully configurable via the <code>context_layout</code> configuration option. The default layout is <code>'source,metadata,status,disass,stack,callstack'</code>.</p> <p>It can either be set globally in the ethpwn configuration file in <code>~/.config/ethpwn/config.json</code> or on a per-debugging session basis via the <code>ethdbg</code> CLI.</p> <pre><code># set a minimal context layout for the current debugging session\nethdbg\u27a4 context_layout 'disass,stack,callstack'\n</code></pre> <pre><code>// set a minimal context layout for all debugging sessions in the config.json\n{\n    ...\n    \"dbg\": {\n        \"context_layout\": \"disass,stack,callstack\"\n        ...\n    }\n}\n</code></pre>"},{"location":"ethdbg/commands/context/#source-view","title":"\ud83d\udc40 Source View","text":"<p>This view is displayed when the account currently executing has source code available in the <code>contract_registry()</code> or the executing contract has verified source code available on Etherscan.</p> <p>To provide source code, a user can either verify their contract source on Etherscan and provide the Etherscan API key in the configuration, or register it in <code>ethpwn</code>'s contract registry.</p> <pre><code># register a contract in the registry using the ethpwn CLI\n$ ethpwn contract register 0x1234... MyContractName  MyContract.sol\n\n# register a contract in the registry using the ethpwn python API\n&gt;&gt;&gt; from ethpwn import *\n&gt;&gt;&gt; CONTRACT_METADATA.compile_solidity_files(['MyContract.sol'])\n&gt;&gt;&gt; CONTRACT_METADATA['MyContractName'].get_contract_at('0x1234...')\n</code></pre> <p>This view highlights the currently executing source code line corresponding to the EVM opcodes displayed in the Disassembly view.</p> <p>Due to the debug information produced by the Solidity and Vyper compilers, this view can become quite large for large contracts. To avoid this, a user can either specify a maximum number of lines to display via the <code>source_view_cutoff</code> option, or by disabling the view entirely by removing it from the <code>context_layout</code>. These settings can be set globally in the ethpwn configuration file in <code>~/.config/ethpwn/config.json</code> or on a per-debugging session basis via the <code>ethdbg</code> CLI.</p>"},{"location":"ethdbg/commands/context/#metadata-view","title":"\ud83d\udc40 Metadata View","text":"<p>The Metadata view displays useful information regarding the currently executing transaction.</p> Field What <code>Fork</code> Version of the EVM currently executing <code>Block</code> Block number at which the current transaction is executing <code>Origin</code> The account that started the transaction <code>Current code account</code> The address of the smart contract currently executing code <code>Current storage account</code> The address of the smart contract whose storage will be referenced during an SSTORE/SLOAD <code>Balance</code> The balance of the Current code account <code>Gas Used</code> The amount of gas used up until the current opcode <code>Gas Remaining</code> How much gas is remaining for this transaction execution"},{"location":"ethdbg/commands/context/#disassembly-view","title":"\ud83d\udc40 Disassembly View","text":"<p>Here we display the currently executing opcode, a small history of opcodes executed up to this point, and a short look-ahead of the following opcodes.</p> <p>(You can see the full history by using the command <code>log_op</code>).</p>"},{"location":"ethdbg/commands/context/#stack-view","title":"\ud83d\udc40 Stack View","text":"<p>A view of the currently active EVM stack.</p>"},{"location":"ethdbg/commands/context/#callstack-view","title":"\ud83d\udc40 Callstack View","text":"<p>The Callstack View provides insight regarding the nested calls that are performed by a transactions to different contracts during execution (i.e., internal transactions created by these opcodes: <code>CALL</code>, <code>DELEGATECALL</code>, <code>STATICCALL</code>, <code>CODECALL</code>, <code>CREATE</code>, <code>CREATE2</code>). This view provides the following information:</p> Field What <code>Address</code> The current code address executing (the target of the last-issued <code>CALL</code>/...) <code>Call Type</code> Type of call, <code>CALL</code>, <code>DELEGATECALL</code>, <code>STATICCALL</code>, <code>CODECALL</code>, <code>CREATE</code>, <code>CREATE2</code> <code>Call Site</code> The program counter value in the caller contract when the last-call was issued <code>msg.sender</code> The value of the <code>msg.sender</code> in this call-context <code>msg.value</code> The amount of ETH sent by the caller for this call-context <code>Name</code> If the contract is in the registry, we display its name here."},{"location":"ethdbg/commands/continue/","title":"continue","text":"<p>Resumes the execution after a breakpoint.</p> <p>Syntax: <code>continue</code></p> <p></p>"},{"location":"ethdbg/commands/disass/","title":"disass","text":"<p>Disassemble <code>&lt;num_instructions&gt;</code> starting from <code>&lt;pc&gt;</code></p> <p>Syntax: <code>disass &lt;pc&gt; &lt;num_instructions&gt;</code></p> <p></p>"},{"location":"ethdbg/commands/ethtowei/","title":"ethtowei","text":"<p>Utility function to convert ETH into wei.</p> <p>Syntax: <code>ethtowei &lt;value&gt;</code></p> <p></p>"},{"location":"ethdbg/commands/finish/","title":"finish","text":"<p>Continue execution until the current function returns (or reverts). Effectively executes until the current callstack entry is removed for any reason.</p> <p>Syntax: <code>finish</code></p> <p>BEFORE: </p> <p>AFTER: </p>"},{"location":"ethdbg/commands/log_op/","title":"log_op","text":"<p>Log and display every opcode executed by the EVM.</p> <p>Syntax: <code>log_op</code> </p> <p></p>"},{"location":"ethdbg/commands/memory/","title":"memory","text":"<p>Display <code>&lt;length&gt;</code> bytes of the memory of the current smart contract executing at a specific <code>&lt;offset&gt;</code>.</p> <p>Syntax: <code>memory &lt;offset&gt; &lt;length&gt;</code></p> <p></p>"},{"location":"ethdbg/commands/next/","title":"next","text":"<p>Continues execution until the execution hits the immediately following instruction.</p> <p>Unlike <code>step</code>, if the next opcode transfers the execution to another smart contract (i.e., <code>CALL</code>,<code>DELEGATECALL</code>,<code>STATICCALL</code>,<code>CODECALL</code>), the execution will continue until the next instruction of the current contract is executed (i.e., the current call instruction will be stepped over and execution breaks once it returns).</p> <p>Syntax: <code>next</code></p> <p>BEFORE <code>next</code>: </p> <p>AFTER <code>next</code>: </p>"},{"location":"ethdbg/commands/sloads/","title":"sloads","text":"<p>Display SLOADs executed by the current storage account, or, the <code>&lt;account&gt;</code> provided by argument.</p> <p>Syntax: <code>sloads [&lt;address&gt;]</code></p> <p></p>"},{"location":"ethdbg/commands/sstores/","title":"sstores","text":"<p>Display SSTOREs executed by the current storage account, or, the <code>&lt;account&gt;</code> provided by argument.</p> <p>Syntax: <code>sstores [&lt;address&gt;]</code></p> <p></p>"},{"location":"ethdbg/commands/start/","title":"start","text":"<p>This command is used to start the EVM execution. By default, we stop at the very first opcode.</p> <p>Syntax: <code>start</code> </p> <p></p>"},{"location":"ethdbg/commands/step/","title":"step","text":"<p>Single-step. Execute the next opcode and stop.</p> <p>If the next opcode transfers the execution to another smart contract (i.e., <code>CALL</code>,<code>DELEGATECALL</code>,<code>STATICCALL</code>,<code>CODECALL</code>), the next instruction you will stop at is in the target contract.</p> <p>Syntax: <code>&lt;step&gt;</code></p> <p>BEFORE <code>step</code>: </p> <p>AFTER <code>step</code>: </p>"},{"location":"ethdbg/commands/storageat/","title":"storageat","text":"<p>Display the value of the current storage <code>&lt;slot&gt;</code> of the current storage account.</p> <p>Syntax: <code>storagat &lt;slot&gt;</code></p> <p></p>"},{"location":"ethdbg/commands/storagelayout/","title":"storagelayout","text":"<p>When the source code of the Current Storage Account is available, this command will display extra information regarding its storage such as variable names, slot locations and the offset (in case of packed slot).</p> <p>Syntax: <code>storagelayout</code></p> <p></p>"},{"location":"ethdbg/commands/tbreak/","title":"tbreak","text":"<p><code>tbreak</code> works like <code>break</code>, but the breakpoint is temporary (removed after it is hit the first time).</p> <p>Syntax: See break</p>"},{"location":"ethdbg/commands/weitoeth/","title":"weitoeth","text":"<p>Utility function to convert wei into ETH.</p> <p>Syntax: <code>weitoeth &lt;value&gt;</code></p> <p></p>"},{"location":"ethpwn/about/","title":"About ethpwn","text":"<p><code>ethpwn</code> aims to make interacting with the Ethereum blockchain easier. Specifically, when it comes to creating, deploying, and interacting with smart contracts, we found ourselves writing the same boilerplate code over and over again or performing such operations in a web browser (bleah!). Comparing this to the state of binary exploitation in CTFs (where the awesome pwntools library is predominantly used to interact with a target program), a lot was left to be desired for web3 hacking.</p> <p><code>ethpwn</code> aims to be the <code>pwntools</code> for smart contracts, and provide a simple, easy to use interface for interacting with them.</p> <p>The main 3 principles for <code>ethpwn</code> are:</p> <ol> <li>allow integration of familiar smart contract technologies where appropriate to reduce the learning curve</li> <li>provide a simple, consistent set of configuration that can simplify the process of interacting with smart contracts</li> <li>prioritize concise, easy to use, high-level API which keeps the most common operations as simple as possible</li> </ol>"},{"location":"ethpwn/about/#installation","title":"\u2699\ufe0f Installation","text":"<p>The main logic of <code>ethpwn</code> is written in Python3, and can be installed via <code>pip</code>:</p> <pre><code>pip install ethpwn\n</code></pre> <p>Specifically, the core logic is found in the <code>ethpwn.ethlib</code> module, where the high-level API is found in <code>ethpwn.ethlib.prelude</code>. For ease-of-use, this is also reexported in <code>ethpwn</code> itself, so that you can do <code>from ethpwn import *</code> to get convenient access to the high-level API functionality.</p> \u2757\ufe0f Note To start out, if you haven't created your global config before, you should run <code>ethpwn config create</code> to generate your initial configuration file. This command will interactively prompt you for the most important settings, including the Ethereum node URL to use and wallets you want to use."},{"location":"ethpwn/cli/","title":"Command Line Tools","text":"<p><code>ethpwn</code> comes with a CLI that can be used to manage, query, and interact with the global state, as well as having shortcuts to create, decode and manipulate transactions. Most components of <code>ethpwn</code> can be accessed via the CLI.</p> <p>Most commands have a help page that should explain what a command will do, see for example <pre><code>ethpwn -h\nethpwn wallet -h\nethpwn wallet add -h\n</code></pre> This should include descriptions of the behavior of the command as well as any arguments it takes.</p>"},{"location":"ethpwn/cli/#tutorials","title":"\ud83d\udc25 Tutorials","text":""},{"location":"ethpwn/cli/#configuration-management-ethpwn-config","title":"Configuration Management (<code>ethpwn config</code>)","text":"<p>This is used to either create a new <code>ethpwn</code> configuration from scratch, or to switch across different configured chains.</p> <pre><code>ethpwn config -h\nusage: ethpwn config [-h] {create,default_network,debug_transaction_errors,set_default_node_url,show} ...\n\nManage config for ethlib\n\npositional arguments:\n  {create,default_network,debug_transaction_errors,set_default_node_url,show}\n    create              Create a new config file with a basic setup. Will interactively prompt you for the necessary information.\n    default_network     Set or get the default network to use\n    debug_transaction_errors\n                        Set or get whether to automatically spawn an ethdbg shell if a transaction fails.\n    set_default_node_url\n                        Sets the default node URL for `network`.\n    show                Show the current config\n\noptional arguments:\n  -h, --help            show this help message and exit\n</code></pre>"},{"location":"ethpwn/cli/#contract-metadata-management-ethpwn-contract","title":"Contract Metadata Management (<code>ethpwn contract</code>)","text":"<p>The most used command is probably <code>ethpwn contract</code>, which can be used to manage contract metadata. This metadata is stored in the <code>ethpwn contract_registry</code>, and can be used by other components of <code>ethpwn</code> to simplify interaction with contracts.</p> <pre><code>$ ethpwn contract -h\nusage: ethpwn contract [-h]\n                       {address,get_default_import_remappings,compile,convert_registry,deploy,register,fetch_verified_contract,decode_calldata}\n                       ...\n\nManage contracts and their metadata\n\npositional arguments:\n  {address,get_default_import_remappings,compile,convert_registry,deploy,register,fetch_verified_contract,decode_calldata}\n    address             Parse an address string into an address. The string can be in checksummed, non-\n                        checksummed, or hex format.\n    get_default_import_remappings\n                        Print the default import remappings.\n    compile             Compile a contract. Returns the contract object. Optionally, you can provide the\n                        contract source code, or a list of source files to compile the contract on the\n                        file.\n    convert_registry    Convert the contract registry from one encoding to another. Valid encodings:\n                        'json', 'msgpack'\n    deploy              Deploy a contract and return the deployed contract instance.\n    register            Register an instance of the contract `contract_name` at `contract_address` in the\n                        contract registry. Optionally, you can provide the contract source code, or a list\n                        of source files to compile the contract first.\n    fetch_verified_contract\n                        Fetch the verified source code for the contract at `address` from Etherscan and\n                        register it in the code-registry. If the contract is not verified, an error is\n                        raised. If the contract is already registered, it is returned.\n    decode_calldata     Decode a transaction. Either `target_contract`+`calldata` or `tx_hash` must be\n                        provided.\n\noptional arguments:\n  -h, --help            show this help message and exit\n\n\n$ ethpwn contract address 0x1234...\n\n# ONLY for testing, has no permanent effect, check to see if the contract compiles\n$ ethpwn contract compile --contract_name MyContract --source_file ~/Downloads/MyContract.sol\n\n# register a contract in the contract registry\n$ ethpwn contract register MyContract 0x1234... --source_file ~/Downloads/MyContract.sol\n</code></pre>"},{"location":"ethpwn/cli/#wallet-management-ethpwn-wallet","title":"Wallet management (<code>ethpwn wallet</code>)","text":"<p><code>ethpwn</code> can manage multiple wallets, and can be used to create new wallets, import existing wallets, and query the balance of wallets.</p> <pre><code>$ ethpwn wallet -h\nusage: ethpwn wallet [-h] {import,add,list,balance} ...\n\nManage wallets for ethlib\n\npositional arguments:\n  {import,add,create,list,balance}\n    import              Import wallets from a file. The file should be a JSON file with a list of wallet objects.\n    add                 Add a wallet to the wallet registry.\n    create              Create a new wallet and add it to the wallet registry.\n    list                List the wallets in the wallet registry.\n    balance             Get the balance of a wallet.\n\noptional arguments:\n  -h, --help            show this help message and exit\n\n # import wallets from another configuration\n$ ethpwn wallet import ~/Downloads/wallets.json\n\n# add a new wallet to the wallet registry\n$ ethpwn wallet add 0xd3362F22C6d517a405b0508a045C2A8861cA3267 &lt;private_key&gt; --name my_wallet --description \"The best wallet ever\" --network sepolia\n\n# list the wallets in the wallet registry\n$ ethpwn wallet list\nWallet(address='0xd3362F22C6d517a405b0508a045C2A8861cA3267', private_key=&lt;blinded&gt;, name='my_wallet', description=\"The best wallet ever\", network='sepolia')\n\n$ ethpwn wallet balance my_wallet\nWallet my_wallet (0xd3362F22C6d517a405b0508a045C2A8861cA3267) on sepolia has 4.784452377989923737 ether (4784452377989923737 wei)\n</code></pre>"},{"location":"ethpwn/cli/#credential-management-ethpwn-credential","title":"Credential Management (<code>ethpwn credential</code>)","text":"<p><code>ethpwn</code> can manage credentials for external services, such as Etherscan. These credentials are stored in the <code>ethpwn</code> configuration file, and can be used by other components of <code>ethpwn</code> to interact with external services.</p> <p>At the moment, the only used service is Etherscan, but more can be added in the future.</p> <pre><code>$ ethpwn credential -h\nusage: ethpwn credential [-h] {add,list,get} ...\n\nManage credentials for ethlib\n\npositional arguments:\n  {add,list,get}\n    add           Add a credential\n    list          Show credentials\n    get           Get a credential\n\noptional arguments:\n  -h, --help      show this help message and exit\n\n$ ethpwn credential add etherscan &lt;etherscan_api_key&gt;\n\n$ ethpwn credential list\n{'etherscan': '&lt;etherscan_api_key&gt;'}\n\n$ ethpwn credential get etherscan\n&lt;etherscan_api_key&gt;\n</code></pre>"},{"location":"ethpwn/cli/#labels-ethpwn-label","title":"Labels (<code>ethpwn label</code>)","text":"<p><code>ethpwn</code> allows you to label common ethereum addresses and contracts for convenient use in all other components of <code>ethpwn</code>. These labels are stored in the <code>ethpwn</code> configuration, and can be used to retrieve contracts from the registry. E.g. Contract addresses can be associated with multiple labels, however each label must be unique.</p> <pre><code>$ ethpwn label -h\nusage: ethpwn label [-h] {add,get,list} ...\n\nManage contract labels\n\npositional arguments:\n  {add,get,list}\n    add           Add a label for a contract address.\n    get           Get the labels of a contract address.\n    list          Show all contract labels.\n\noptional arguments:\n  -h, --help      show this help message and exit\n\n$ ethpwn label add my_label 0x1234...\n\n$ ethpwn label get 0x1234...\n['my_label']\n\n$ ethpwn label list\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Contract Address                           \u2503 Label             \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 0x1234...                                  \u2502 asdf              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"ethpwn/evmanalyzers/","title":"EVM Analyzers","text":"<p>One of the coolest feature of <code>ethpwn</code> is that it makes it very easy to build custom analyses for the EVM in a customizable context. This is accomplished through the <code>EVMAnalyzer</code> and its <code>Plugins</code>. We ship a couple of basic plugins as example, but very complicated plugins can be constructed with this methodology :) Moreover, plugins are realized through specific hooks in the EVM, you can combine multiple plugins to implement advanced analyses!</p> <p>For instance, let's say you want to collect all the SLOAD(s) done by one of the transaction with index 2 at block <code>12131212</code>, you just have to do:</p> <p>Script:</p> <pre><code>    from ethpwn import *\n    from ethpwn.ethlib.evm.plugins.sload_tracer import SLoadTracer\n\n    # Get EVM at block \n    a = get_evm_at_block(12131212)\n\n    # Apply the first transaction in the block\n    a.next_transaction()\n\n    # Instantiate the SLOAD tracer plugin\n    sload_tracer = SLoadTracer()\n\n    # Register the plugin in the system \n    a.register_plugin(sload_tracer)\n\n    # Analyze the transaction 2\n    a.next_transaction()\n\n    # Get results!\n    a.plugins.sload_tracer.traced_sloads\n</code></pre> <p>Output:</p> <pre><code>    [TracedSLoad(id=1, slot=b'\\x93\\xa4\\xc8\\x1e\\xfe\\xdf\\x97\\xddPt\\x113\\xdfR\\xf8\\xcf.~\\x0b\\xc7}\\xe3G\\x88\\xa6j\\x1f\\xd7\\xc8\\xa11\\xbf', pc=1152, value=b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd8\\xd7&amp;\\xb7\\x17z\\x80\\x00\\x00'), .... ]\n</code></pre>"},{"location":"ethpwn/getting_started/","title":"Getting Started","text":"<p><code>ethpwn</code> aims to solve a few tasks that users might commonly come in contact with. To become acquainted with <code>ethpwn</code>, let's start by walking through several examples.</p> <p>Similary to <code>pwntools</code>, <code>ethpwn</code> follows the \u201ckitchen sink\u201d approach.</p> <pre><code>from ethpwn import *\n</code></pre> <p>This imports all you need to start compiling and interacting with smart contracts.</p>"},{"location":"ethpwn/getting_started/#tutorials","title":"\ud83d\udc25 Tutorials","text":""},{"location":"ethpwn/getting_started/#compiling-smart-contracts","title":"Compiling smart contracts","text":"<p>Smart contracts are usually written in high-level programming languages, most commonly Solidity or sometimes Vyper.</p> <p><code>ethpwn</code> provides a simple interface for compiling smart contracts and analyzing their compilation artifacts.</p> <pre><code>&gt;&gt;&gt; from ethpwn import *\n\n&gt;&gt;&gt; CONTRACT_METADATA.compile_solidity_files(['contract_a.sol', 'contract_b.sol'])\n&gt;&gt;&gt; contract_a = CONTRACT_METADATA['ContractA']\n&gt;&gt;&gt; print (f\"ContractA: ABI: {contract_a.abi}\")\n&gt;&gt;&gt; print (f\"ContractA: deployed bytecode: {contract_a.bin_runtime}\")\n&gt;&gt;&gt; print (f\"ContractA: storage layout: {contract_a.storage_layout}\")\n&gt;&gt;&gt; print (f\"ContractA: source code for pc=0x1234: {contract_a.source_info_for_pc(0x1234)}\")\n\n&gt;&gt;&gt; calldata = '0x12345678abcdef'\n&gt;&gt;&gt; func_name, args = contract_a.decode_function_input(calldata)\n&gt;&gt;&gt; print (f\"ContractA: calldata calls function {func_name} with args {args}\")\n</code></pre> <p>In addition to the compiled information accessible via the <code>ContractMetadata</code>, <code>ethpwn</code> also provides way to interact with deployed instances of a contract on the blockchain.</p>"},{"location":"ethpwn/getting_started/#deploying-smart-contracts","title":"Deploying smart contracts","text":"<p>A contract instance can be retrieved either by deploying a new contract via <code>ContractMetadata.deploy()</code>, or by the address of an already deployed contract via <code>ContractMetadata.get_contract_at()</code>.</p> <pre><code># deploy an instance of ContractA onto the blockchain\n# calls the contract's constructor with arguments 0, 1, and 2\n&gt;&gt;&gt; _, deployed_contract_a = contract_a.deploy(0, 1, 2)\n&gt;&gt;&gt; deployed_contract_a_address = deployed_contract_a.address\n# get an instance of ContractA on the blockchain at the address obtained at the step before\n&gt;&gt;&gt; contract_a_instance = deployed_contract_a.get_contract_at(deployed_contract_a_address)\n</code></pre> <p>In both cases, <code>ethpwn</code> associates the address of the contract with the contract metadata by registering it in the ContractRegistry for future use. The provided <code>Contract</code> instance can be used to interact with it using the Web3py API.</p>"},{"location":"ethpwn/getting_started/#interacting-with-smart-contracts","title":"Interacting with smart contracts","text":"<p><code>ethpwn</code>'s <code>transact()</code> is your one-stop shop for creating new transactions. It estimates the gas costs of a transaction, checks that the funds necessary are available before launching it, handles transactions reverting by simulating them first, etc. Lastly, it automatically launches <code>ethdbg</code> to debug the transaction in case it fails or reverts. This feature can be enabled either by passing <code>debug_transaction_errors=True</code> to <code>transact()</code>, or, by setting the <code>debug_transaction_errors</code> flag in your <code>ethpwn</code> configuration (<code>ethpwn config debug_transaction_errors --set-to True</code>)</p> <pre><code># simulate the result of calling the `foo` function on the contract with arguments 0, 1, and 2\n&gt;&gt;&gt; result = contract_a_instance.functions.foo(0, 1, 2).call()\n\n# create a transaction on the real blockchain calling the `foo` function on the contract with arguments 0, 1, and 2\n&gt;&gt;&gt; transact(contract_a_instance.functions.foo(0, 1, 2))\n\n# create the same transaction, but ensure ethdbg is launched if the transaction fails or reverts\n&gt;&gt;&gt; transact(contract_a_instance.functions.foo(0, 1, 2), debug_transaction_errors=True)\n\n# create a transaction with raw calldata\nccc = contract_registry().get(0x0AC6f85872C1e5309dEc61f94B10196ea1d248d0)\ncalldata = bytes.fromhex('30c13ade000000000001231031230102310230123')\ntransact(to=ccc.address, data=calldata, force=True)\n</code></pre>"},{"location":"ethpwn/getting_started/#assembling-and-disassembling-evm-code","title":"Assembling and Disassembling EVM code","text":"<p>Easy API to assemble and disassemble EVM bytecode!</p> <pre><code>&gt;&gt;&gt; from ethpwn import *\n&gt;&gt;&gt; bytecode = assemble_pro(\"\"\"\n...   PUSH1 0x40\n...   PC\n...   PC\n...   PC\n...   PUSH1 0x00\n...   PUSH1 0x01\n...   SSTORE\n... \"\"\")\n&gt;&gt;&gt; print(bytecode)\n60405858586000600155\n</code></pre> <pre><code>&gt;&gt;&gt; from ethpwn import *\n&gt;&gt;&gt; print(disassemble_pro('60405858586000600155'))\n0000: 60 40        PUSH1 0x40          [gas=3, description=\"Place 1 byte item on stack.\"]\n0002: 58           PC                  [gas=2, description=\"Get the value of the program counter prior to the increment.\"]\n0003: 58           PC                  [gas=2, description=\"Get the value of the program counter prior to the increment.\"]\n0004: 58           PC                  [gas=2, description=\"Get the value of the program counter prior to the increment.\"]\n0005: 60 00        PUSH1 0x0           [gas=3, description=\"Place 1 byte item on stack.\"]\n0007: 60 01        PUSH1 0x1           [gas=3, description=\"Place 1 byte item on stack.\"]\n0009: 55           SSTORE              [gas=0, description=\"Save word to storage.\"]\n</code></pre>"},{"location":"ethpwn/getting_started/#testing-evm-bytecode-on-the-fly","title":"Testing EVM bytecode on-the-fly","text":"<p><code>pwnlib.runner.run_assembly</code> anyone? :)</p> <pre><code>&gt;&gt;&gt; from ethpwn import *\n&gt;&gt;&gt; bytecode = assemble_pro(\"PUSH1 0x40\\nPC\\nPC\\nPC\\nPUSH1 0x00\\nPUSH1 0x01\\nSSTORE\\n\")\n&gt;&gt;&gt; debug_shellcode(bytecode) # this will spawn an ethdbg session.\nDebugger launched, press enter to continue...\n</code></pre>"},{"location":"ethpwn/global_state/","title":"Global State","text":"<p><code>ethpwn</code> maintains a variety of global state across runs to allow the interaction scripts to focus only on the logic of the interaction, and not on the boilerplate of setting up the environment.</p> <p>Specifically, <code>ethpwn</code> maintains the following concepts in a global state: global parameters (e.g., API keys, wallets), settings, and the contract registry.</p>"},{"location":"ethpwn/global_state/#configuration","title":"\ud83d\udcdd Configuration","text":"\u2757\ufe0f Note To start out, if you haven't created your global config before, you should run <code>ethpwn config create</code> to generate your initial configuration file. This command will interactively prompt you for the most important settings, including the Ethereum node URL to use and wallets you want to use. <p>The configuration for <code>ethpwn</code> is located at <code>~/.config/ethpwn/config.json</code>. This file allows you to configure a variety of settings globally, which are then used by the various modules to simplify the interaction process.</p> <p>You can use the <code>ethpwn config</code> and <code>ethpwn wallet</code> commands to modify the most common configuration settings, or you can edit the file directly.</p> <p>The most important settings are the following:</p> <ol> <li><code>default_network</code>: the default network to use for all interactions (currently supported: <code>mainnet</code> and <code>sepolia</code>)</li> <li><code>default_node_urls</code>: per-network default Ethereum node URLs to retrieve blockchain information state</li> <li><code>wallets</code>: Ethereum wallets to interact with the different blockchain networks</li> <li><code>etherscan_api_key</code>: API key for Etherscan to retrieve verified source code for contracts</li> <li><code>debugger configuration</code>: settings for <code>ethdbg</code>. See ethdbg.</li> </ol> <p>The configuration is structured as follows and is shared between <code>ethdbg</code> and <code>ethpwn</code>:</p> <pre><code>{\n  \"default_network\": \"mainnet\",\n  \"default_node_urls\": {\n    \"mainnet\": \"&lt;YOUR_ETHEREUM_NODE_URL&gt;\",\n  },\n  \"credentials\": {\n    \"etherscan\": \"&lt;OPTIONAL_ETHERSCAN_API&gt;\"\n  },\n  \"dbg\": {\n  }\n}\n</code></pre> <p>The other configuration file is <code>~/.config/ethpwn/wallets.json</code> and contains the Ethereum wallet configuration to use with <code>ethpwn</code>.</p> <p>An example of such a configuration is the following:</p> <pre><code>[\n  {\n    \"address\": \"0x1a5984F43dAD95a5121b1b30B9190d619d84d21C\",\n    \"private_key\": \"0x2838aa1e473a046941d3ee4481396b9c54c944a6b6321e489b654554125f374b\",\n    \"network\": \"mainnet\",\n    \"name\": \"my-test-wallet\",\n    \"description\": \"Default wallet generated by ethpwn on 2023-07-09 13:12:05.184774\"\n  }\n]\n</code></pre> \ud83d\uded1 Warning !!!!! DO NOT use accounts and private keys that hold valuable assets in this config file! This file is NOT protected in any way. Putting sensitive private keys here might lead to exposing them in the clear and can cause the loss of funds on the related account if someone can steal them. ALWAYS use test accounts!"},{"location":"ethpwn/global_state/#contractregistry","title":"\ud83d\udcda ContractRegistry","text":"<p>The contract registry is your personal library of smart contract metadata. At a high-level, the contract-registry is simply a mapping from contract addresses to their corresponding metadata.</p> <p>Contracts are automatically added to the contract registry by <code>ethpwn</code> in the following cases:</p> <ol> <li>You deploy a smart contract via <code>ContractMetadata.deploy()</code></li> <li>You interact with a verified contract on-chain (if you have a valid Etherscan API configured)</li> <li>You manually register contract metadata with a contract instance via <code>ContractMetadata.get_contract_at(&lt;address&gt;)</code> (or with the CLI)</li> </ol> <p><code>ethpwn</code> then stores this association in its global <code>ContractRegistry</code> object, which can be accessed via <code>contract_registry()</code>. The contract registry is stored locally on your machine in <code>~/.config/ethpwn/contract_registry/</code> by default and will be loaded every time you use <code>ethpwn</code>.</p> <p>The example in the tutorial below illustrates this by retrieving a contract instance for the UniswapRouter contract from the contract registry, and then using it to interact with the contract without having to specify the address, ABI, storage layout, or source code of the contract.</p>"},{"location":"ethpwn/global_state/#etherscan-verified-source-code","title":"\u2705 Etherscan Verified Source Code","text":"<p>If you have configured <code>ethpwn</code> with an Etherscan API key, <code>ethpwn</code> can fetch source code for contracts from Etherscan's verified contracts library. This allows you to transparently retrieve the metadata for these contracts without needing to explicitly compile them yourself. The target contract is automatically compiled and added to the contract registry for you.</p> <p>To use this feature, set the <code>ETHERSCAN_API_KEY</code> environment variable to your etherscan API key, or add it to your <code>ethpwn</code> configuration file.</p> <p>Then you can use the following command to fetch the verified source code for, e.g., the Uniswap Router contract: <pre><code>ethpwn contract fetch_verified_contract 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n</code></pre></p> <p>Or, in a Python script, you can do the following: <pre><code>from ethpwn import *\n\n# either specify the API key in the environment or the configuration file\ninstance = fetch_verified_contract(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D)\n\n# or specify it explicitly\ninstance = fetch_verified_contract(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, api_key='&lt;YOUR_API_KEY&gt;')\n</code></pre></p>"},{"location":"ethpwn/global_state/#contractmetadata","title":"\ud83d\uddc3 ContractMetadata","text":"<p>Whenever you compile contracts within a Python script, <code>ethpwn</code> manages the compiled contract metadata in a temporary <code>ContractMetadata</code> object that can be accessed via the <code>CONTRACT_METADATA</code> variable.</p> <p>Note that, this object does NOT persist after the termination of your script. Instead, we store the corresponding <code>ContractMetadata</code> object only when you record a deployed contract in the <code>contract_registry</code> (in this case the contract being deployed is unambiguous).</p> <p>The contract metadata contains, among other things, the following information:</p> <ul> <li><code>metadata.compiler</code> - the compiler used to compile the contract</li> <li><code>metadata.sources</code> - the sources used to compile the contract</li> <li><code>metadata.source_file</code> - the source file the current contract is found in</li> <li><code>metadata.contract_name</code> - the name of the contract</li> <li><code>metadata.bin_runtime</code> - the bytecode of the contract deployed on the blockchain</li> <li><code>metadata.srcmap_runtime</code> - the source map of the deployed contract</li> <li><code>metadata.abi</code> - the ABI of the contract, used to interact with the contract</li> <li><code>metadata.storage_layout</code> - the storage layout of the contract, used to display and retrieve storage variables in <code>ethdbg</code></li> </ul> <p>It also provides various helper functions to manipulate or analyze instances of this contract, e.g.</p> <pre><code>  def source_info_for_pc(self, pc, fork='paris') -&gt; InstructionSourceInfo:\n    '''\n    Returns the source info for the instruction at the given program counter in the deployed bytecode.\n    '''\n\n  def deploy(self, *constructor_args, **tx_extras) -&gt; Tuple[HexBytes, Contract]:\n    '''\n    Deploys an instance of this contract to the blockchain and registers it with the contract registry.\n    '''\n\n  def get_contract_at(self, addr) -&gt; Contract:\n    '''\n    Returns a web3 contract instance for the contract at the given address. This will\n    automatically register this contract instance with the contract registry.\n    '''\n\n  def decode_function_input(self, data):\n    '''\n    Decodes the function input data for a contract of this class. Returns a tuple of the\n    function name and a dictionary of the arguments.\n    '''\n</code></pre> <p>In the current session you can retrieve contract metadata by contract name, e.g., if you have previously compiled the code of the uniswap router contract, you can use <code>CONTRACT_METADATA['UniswapV2Router02']</code> to retrieve the <code>ContractMetadata</code> for this contract.</p> <p>You can also retrieve the <code>ContractMetadata</code> for a contract that is stored in the <code>contract_registry</code> by using <code>contract_registry().get(&lt;contract_address&gt;).metadata</code>.</p>"},{"location":"ethpwn/global_state/#tutorial","title":"\ud83d\udc25 Tutorial","text":"<p>Here is an example of how you can leverage the global states used and exported by <code>ethpwn</code> in your scripts.</p> <p>The following example relies on the following setup using the <code>ethpwn</code> CLI:</p> <pre><code>##########\n\n# set up labels for the contracts we want to use for easy access\nethpwn label add 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D uniswap-router\nethpwn label add 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 WETH-token\nethpwn label add 0x6B175474E89094C44Da98b954EedeAC495271d0F DAI-token\n\n# fetch the verified source code for the uniswap router contract from etherscan to access its metadata and ABI\nethpwn contract fetch_verified_source 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n</code></pre>"},{"location":"ethpwn/global_state/#direct-interaction-in-ethpwn-scripts","title":"Direct Interaction in <code>ethpwn</code> Scripts","text":"<p>Then, we can use the uniswap router contract in our scripts to interact with it. <pre><code>from ethpwn import *\n\n# output to default wallet (can also specify wallet name or address here)\nOUT_ADDR = get_wallet(None).address\n\n# deadline: at most 30 minutes\ndeadline = int(time.time()) + 30 * 60\n\nswap_path = [\n    contract_by_label('WETH-token'), # swap first to WETH\n    contract_by_label('DAI-token')   # then to DAI\n]\n\n# fetch the Contract instance for the uniswap router contract\n# this automatically retrieves the ABI, source code,\n# and storage layout for the contract\nuniswap_router = contract_registry().get(contract_by_label('uniswap-router'))\n\ntransact(\n    # this uses the automatic abi to encode the function call\n    uniswap_router.w3().swapExactETHForTokens(\n        100,        # amountOutMin: we want at least 100 DAI\n        swap_path,  # path\n        OUT_ADDR,   # to\n        deadline,   # deadline\n    ),\n    value=1 * ETHER\n)\n</code></pre></p>"},{"location":"ethpwn/global_state/#integration-in-contract-deployment","title":"Integration in contract deployment","text":"<p>Instead of performing this action manually, we can also deploy a solidity contract to perform this action for us.</p> <pre><code>from ethpwn import *\n\nsolidity_source = \"\"\"\npragma solidity ^0.6.0;\n\ninterface IUniswapV2Router02 {\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n}\n\ncontract Swapper {\n    IUniswapV2Router02 uniswap_router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    address WETH_addr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address DAI_addr = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address my_addr = 0x1234567890123456789012345678901234567890;\n    uint deadline = block.timestamp + 30 * 60; // 30 minutes at most\n\n    function getDAI(uint amountOutMin) public payable {\n        uniswap_router.swapExactETHForTokens{value: msg.value}(\n            amountOutMin,\n            [WETH_addr, DAI_addr],\n            my_addr,\n            deadline\n        );\n    }\n}\n\"\"\"\n\n# compile the contract\ncontract_metadata = CONTRACT_METADATA.compile_solidity_source(solidity_source, 'Swapper.sol')\n\n# deploy the contract\ncontract_instance = contract_metadata.deploy()\n\n# call the contract's `getDAI` function\ntxid, *_ = transact(contract_instance.w3.getDAI(100), value=1 * ETHER)\nprint(f\"Transaction ID: {txid.hex()}\")\n</code></pre>"},{"location":"ethpwn/global_state/#integration-with-ethdbg","title":"Integration with <code>ethdbg</code>","text":"<p>Additionally, we can use <code>ethdbg</code> to debug any transactions interacting with the contract instance we just deployed. Thanks to the contract registry, <code>ethdbg</code> will automatically have the contract metadata available during the debug sessions and display both the source code information and the storage layout for the contract.</p> <p>If we registered the UniswapV2Router02 contract with the registry as the previous example did, <code>ethdbg</code> will display the source code and storage information for that contract as well. <pre><code># ensure the debug information for UniswapV2Router02 is available\nethpwn contract fetch_verified_source 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n\n# launch ethdbg to debug the transaction, this should display the source code and storage layout for both contracts\nethdbg --txid &lt;id of the transaction we just attempted&gt;\n</code></pre></p>"},{"location":"ethpwn/modules/assembly_utils/","title":"ethpwn.ethlib.assembly_utils","text":""},{"location":"ethpwn/modules/assembly_utils/#ethpwnethlibassembly_utils","title":"ethpwn.ethlib.assembly_utils","text":"<p>Module containing utility functions for assembling and disassembling EVM bytecode manually and automatically.</p> <p></p>"},{"location":"ethpwn/modules/assembly_utils/#value_to_smallest_hexbytes","title":"value_to_smallest_hexbytes","text":"<pre><code>def value_to_smallest_hexbytes(value)\n</code></pre> <p>Convert an integer to the smallest possible hexbytes</p> <p></p>"},{"location":"ethpwn/modules/assembly_utils/#asm_push_value","title":"asm_push_value","text":"<pre><code>def asm_push_value(value)\n</code></pre> <p>Push value to the stack</p> <p></p>"},{"location":"ethpwn/modules/assembly_utils/#asm_codecopy","title":"asm_codecopy","text":"<pre><code>def asm_codecopy(dst, src, size)\n</code></pre> <p>Copy code from src to dst</p> <p></p>"},{"location":"ethpwn/modules/assembly_utils/#asm_return","title":"asm_return","text":"<pre><code>def asm_return(mem_offset, length)\n</code></pre> <p>Return a value from memory</p> <p></p>"},{"location":"ethpwn/modules/assembly_utils/#asm_mstore","title":"asm_mstore","text":"<pre><code>def asm_mstore(mem_offset, value)\n</code></pre> <p>Store value at key</p> <p></p>"},{"location":"ethpwn/modules/assembly_utils/#asm_mload","title":"asm_mload","text":"<pre><code>def asm_mload(mem_offset)\n</code></pre> <p>Load value at key</p> <p></p>"},{"location":"ethpwn/modules/assembly_utils/#asm_sstore","title":"asm_sstore","text":"<pre><code>def asm_sstore(key, value)\n</code></pre> <p>Store value at key</p> <p></p>"},{"location":"ethpwn/modules/assembly_utils/#asm_sload","title":"asm_sload","text":"<pre><code>def asm_sload(key)\n</code></pre> <p>Load value at key</p> <p></p>"},{"location":"ethpwn/modules/assembly_utils/#create_shellcode_deployer_bin","title":"create_shellcode_deployer_bin","text":"<pre><code>def create_shellcode_deployer_bin(shellcode)\n</code></pre> <p>Create a contract that deploys shellcode at a specific address</p> <p>The deployer code is as follows: <pre><code>PUSH &lt;len(shellcode)&gt;   # len\nPUSH &lt;offsetof label&gt;   # src (offset of shellcode in the deployer)\nPUSH 0                  # dst-offset\nCODECOPY                # copy shellcode to offset 0 from &lt;code&gt; + &lt;offsetof label&gt;\n\nPUSH &lt;len(shellcode)&gt;   # length to return\nPUSH 0                  # offset to return\nRETURN                  # return shellcode\nlabel:\n    &lt;shellcode goes here&gt;\n</code></pre></p> <p></p>"},{"location":"ethpwn/modules/assembly_utils/#disassemble_pro","title":"disassemble_pro","text":"<pre><code>def disassemble_pro(code, start_pc=0, fork='paris')\n</code></pre> <p>Disassemble code and return a string containing the disassembly. This disassembly includes the pc, bytes, instruction, gas cost, and description of each instruction in addition to the standard disassembly.</p> <p></p>"},{"location":"ethpwn/modules/assembly_utils/#assemble_pro","title":"assemble_pro","text":"<pre><code>def assemble_pro(code, start_pc=0, fork='paris')\n</code></pre> <p>Assemble code and return a string containing the bytecode. code is a string such as:     '''PUSH1 0x60          PUSH1 0x40          MSTORE      '''</p> <p></p>"},{"location":"ethpwn/modules/assembly_utils/#debug_shellcode","title":"debug_shellcode","text":"<pre><code>def debug_shellcode(code, ethdbg=True)\n</code></pre> <p>Run on-the-fly EVM bytecode inside ethdbg. code is the bytecode as a string such (the deploying bytecode does not need to be included)</p> <p></p>"},{"location":"ethpwn/modules/assembly_utils/#debug_contract","title":"debug_contract","text":"<pre><code>def debug_contract(code, abi, ethdbg=True)\n</code></pre> <p>Run the bytecode of a smart contract inside ethdbg. code is the run-time bytecode, abi is the abi of the contract</p>"},{"location":"ethpwn/modules/cli/","title":"Table of Contents","text":"<ul> <li>ethpwn.ethlib.cli</li> </ul>"},{"location":"ethpwn/modules/cli/#ethpwnethlibcli","title":"ethpwn.ethlib.cli","text":""},{"location":"ethpwn/modules/compilation/","title":"Table of Contents","text":"<ul> <li>ethpwn.ethlib.compilation</li> </ul>"},{"location":"ethpwn/modules/compilation/#ethpwnethlibcompilation","title":"ethpwn.ethlib.compilation","text":""},{"location":"ethpwn/modules/config/","title":"Table of Contents","text":"<ul> <li>ethpwn.ethlib.config</li> </ul>"},{"location":"ethpwn/modules/config/#ethpwnethlibconfig","title":"ethpwn.ethlib.config","text":""},{"location":"ethpwn/modules/contract_labels/","title":"Contract labels","text":""},{"location":"ethpwn/modules/contract_labels/#ethpwnethlibcontract_labels","title":"ethpwn.ethlib.contract_labels","text":""},{"location":"ethpwn/modules/contract_labels/#contractlabels-objects","title":"ContractLabels Objects","text":"<pre><code>class ContractLabels()\n</code></pre> <p>Maps contract addresses to contract labels. Serialized to the local configuration directory to ensure persistence across runs. This allows us to remember all contracts we've referred to by a label in the past.</p> <p></p>"},{"location":"ethpwn/modules/contract_labels/#register_contract_label","title":"register_contract_label","text":"<pre><code>def register_contract_label(contract_address, contract_label)\n</code></pre> <p>Assign the given contract address to a label.</p> <p></p>"},{"location":"ethpwn/modules/contract_labels/#get_contract_labels","title":"get_contract_labels","text":"<pre><code>def get_contract_labels(contract_address) -&gt; List[str]\n</code></pre> <p>Get the labels registered for a given contract address.</p> <p></p>"},{"location":"ethpwn/modules/contract_labels/#get_contract_address","title":"get_contract_address","text":"<pre><code>def get_contract_address(label) -&gt; str\n</code></pre> <p>Get the address of the given contract label.</p> <p></p>"},{"location":"ethpwn/modules/contract_labels/#store","title":"store","text":"<pre><code>def store(contract_labels_path)\n</code></pre> <p>Store the labels to the given JSON file.</p> <p></p>"},{"location":"ethpwn/modules/contract_labels/#load","title":"load","text":"<pre><code>@staticmethod\ndef load(contract_labels_path) -&gt; 'ContractLabels'\n</code></pre> <p>Load the labels from the given JSON path.</p> <p></p>"},{"location":"ethpwn/modules/contract_labels/#contract_labels","title":"contract_labels","text":"<pre><code>def contract_labels() -&gt; ContractLabels\n</code></pre> <p>Get the global contract labels. Loads the registry from disk if it is not already loaded.</p> <p></p>"},{"location":"ethpwn/modules/contract_labels/#load_or_create_contract_labels","title":"load_or_create_contract_labels","text":"<pre><code>def load_or_create_contract_labels() -&gt; ContractLabels\n</code></pre> <p>Load the contract labels from disk, or create a new one if it does not exist.</p> <p></p>"},{"location":"ethpwn/modules/contract_labels/#register_contract_label_1","title":"register_contract_label","text":"<pre><code>def register_contract_label(address, label)\n</code></pre> <p>Helper function to easily register a contract at a given address. If the contract is already registered, it is updated / merged with the new information.</p> <p></p>"},{"location":"ethpwn/modules/contract_labels/#contract_by_label","title":"contract_by_label","text":"<pre><code>def contract_by_label(label)\n</code></pre> <p>Helper function to easily get the address of a contract by label.</p> <p></p>"},{"location":"ethpwn/modules/contract_labels/#labels_for_contract","title":"labels_for_contract","text":"<pre><code>def labels_for_contract(address)\n</code></pre> <p>Helper function to easily get the labels of a contract by address.</p> <p></p>"},{"location":"ethpwn/modules/contract_labels/#label_for_contract","title":"label_for_contract","text":"<pre><code>def label_for_contract(address)\n</code></pre> <p>Helper function to easily get a label of a contract by address.</p>"},{"location":"ethpwn/modules/contract_metadata/","title":"ethpwn.ethlib.contract_metadata","text":""},{"location":"ethpwn/modules/contract_metadata/#ethpwnethlibcontract_metadata","title":"ethpwn.ethlib.contract_metadata","text":"<p>Module for everything to do with the contract metadata we have available. Contains the metadata registry which is our knowledge base of all the contracts we know about, and the <code>ContractMetadata</code> class which describes and holds that metadata for a single contract.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#get_language_for_compiler","title":"get_language_for_compiler","text":"<pre><code>def get_language_for_compiler(compiler)\n</code></pre> <p>Extract a language identifier from a given compiler json_output['compiler'] string.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#contractmetadata-objects","title":"ContractMetadata Objects","text":"<pre><code>class ContractMetadata(Serializable)\n</code></pre> <p>Holds all of the available metadata about a contract. Includes the ABI, the bytecode, the source code, and the source map.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#from_compiler_output_json","title":"from_compiler_output_json","text":"<pre><code>@staticmethod\ndef from_compiler_output_json(compiler, source_file, contract_name,\n                              output_json, input_sources, output_sources)\n</code></pre> <p>Constructs a ContractMetadata object for a contract in <code>source_file</code> with name <code>contract_name</code> from the Compiler <code>output_json</code> and the <code>sources</code> dict.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#to_serializable","title":"to_serializable","text":"<pre><code>def to_serializable()\n</code></pre> <p>Returns a serializable dictionary representation of the object.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#from_serializable","title":"from_serializable","text":"<pre><code>@staticmethod\ndef from_serializable(value)\n</code></pre> <p>Loads a ContractMetadata object back from a serialized dictionary.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#language","title":"language","text":"<pre><code>@property\ndef language() -&gt; Union[Literal['vyper'], Literal['solidity']]\n</code></pre> <p>Based on the <code>compiler</code> property, return the language the given contract was written in. Currently supports <code>vyper</code> and <code>solidity</code>.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#compiler_name","title":"compiler_name","text":"<pre><code>@property\ndef compiler_name() -&gt; Union[Literal['vyper'], Literal['solc']]\n</code></pre> <p>Based on the <code>compiler</code> property, return the name of the compiler used to compile the contract. Currently supports <code>vyper</code> and <code>solc</code>. Does not include version/commit information.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#selectors","title":"selectors","text":"<pre><code>@property\ndef selectors()\n</code></pre> <p>Fuck-e you Coglione.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#constructor_source_by_id","title":"constructor_source_by_id","text":"<pre><code>def constructor_source_by_id(_id)\n</code></pre> <p>Looks up and returns the source code object for the given source id in the constructor code.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#runtime_source_by_id","title":"runtime_source_by_id","text":"<pre><code>def runtime_source_by_id(_id)\n</code></pre> <p>Looks up and returns the source code object for the given source id in the runtime code.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#symbolic_srcmap_constructor","title":"symbolic_srcmap_constructor","text":"<pre><code>@property\ndef symbolic_srcmap_constructor()\n</code></pre> <p>Returns the symbolized source map for the constructor bytecode.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#symbolic_srcmap_runtime","title":"symbolic_srcmap_runtime","text":"<pre><code>@property\ndef symbolic_srcmap_runtime()\n</code></pre> <p>Returns the symbolized source map for the runtime bytecode.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#closest_instruction_index_for_constructor_pc","title":"closest_instruction_index_for_constructor_pc","text":"<pre><code>def closest_instruction_index_for_constructor_pc(pc, fork='paris') -&gt; int\n</code></pre> <p>Returns the index of the closest instruction in the constructor bytecode that is before or at the given pc in the constructor bytecode.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#closest_instruction_index_for_runtime_pc","title":"closest_instruction_index_for_runtime_pc","text":"<pre><code>def closest_instruction_index_for_runtime_pc(pc, fork='paris') -&gt; int\n</code></pre> <p>Returns the index of the closest instruction in the runtime bytecode that is before or at the given pc in the runtime bytecode.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#source_info_for_constructor_instruction_idx","title":"source_info_for_constructor_instruction_idx","text":"<pre><code>def source_info_for_constructor_instruction_idx(\n        insn_idx) -&gt; InstructionSourceInfo\n</code></pre> <p>Returns the source info for instruction at index <code>insn_idx</code> in the constructor bytecode.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#source_info_for_constructor_pc","title":"source_info_for_constructor_pc","text":"<pre><code>def source_info_for_constructor_pc(pc, fork='paris') -&gt; InstructionSourceInfo\n</code></pre> <p>Returns the source info for the instruction at the given pc in the constructor bytecode.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#source_info_for_runtime_instruction_idx","title":"source_info_for_runtime_instruction_idx","text":"<pre><code>def source_info_for_runtime_instruction_idx(insn_idx) -&gt; InstructionSourceInfo\n</code></pre> <p>Returns the source info for instruction at index <code>insn_idx</code> in the runtime bytecode.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#source_info_for_pc","title":"source_info_for_pc","text":"<pre><code>def source_info_for_pc(pc, fork='paris') -&gt; InstructionSourceInfo\n</code></pre> <p>Returns the source info for the instruction at the given program counter in the deployed bytecode.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#deploy","title":"deploy","text":"<pre><code>def deploy(*constructor_args,\n           **tx_extras) -&gt; Tuple[HexBytes, 'ContractInstance']\n</code></pre> <p>Deploys an instance of this contract to the blockchain and registers it with the contract registry.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#deploy_destructible","title":"deploy_destructible","text":"<pre><code>@contextmanager\ndef deploy_destructible(*constructor_args, **tx_extras)\n</code></pre> <p>Deploys a <code>Destructible</code> contract and <code>destroy()</code>s it after the context manager exits to retrieve any held funds. Utility function for quick one-off contracts so you can easily get your funds back by default. The resulting deployed contract will also be automatically registered with the contract registry.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#get_contract_at","title":"get_contract_at","text":"<pre><code>def get_contract_at(addr) -&gt; 'ContractInstance'\n</code></pre> <p>Returns a web3 contract instance for the contract at the given address. This will automatically register this contract instance with the contract registry.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#decode_function_input","title":"decode_function_input","text":"<pre><code>def decode_function_input(data)\n</code></pre> <p>Decodes the function input data for a contract of this class. Returns a tuple of the function name and a dictionary of the arguments.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#contractmetadataregistry-objects","title":"ContractMetadataRegistry Objects","text":"<pre><code>class ContractMetadataRegistry()\n</code></pre> <p>A registry containing all contracts and metadata for them that we know about. This is used to retrieve information about deployed contracts, associate new contracts with their metadata, and to retrieve metadata for contracts that are not deployed yet. This is the central point for all contract-related metadata.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#compile_solidity_string","title":"compile_solidity_string","text":"<pre><code>def compile_solidity_string(source: str, file_name: Union[Path, str],\n                            **kwargs)\n</code></pre> <p>Compiles the given solidity source code and adds the resulting metadata of all contracts to the registry.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#compile_solidity_sources_dict","title":"compile_solidity_sources_dict","text":"<pre><code>def compile_solidity_sources_dict(sources: Dict[str, str], **kwargs)\n</code></pre> <p>Compiles the given solidity source dict <code>'sources'</code> in the input json and adds the resulting metadata of all contracts to the registry.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#compile_solidity_files","title":"compile_solidity_files","text":"<pre><code>def compile_solidity_files(files: List[Union[str, Path]], **kwargs)\n</code></pre> <p>Compiles the given files and adds the resulting metadata of all contracts to the registry.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#compile_solidity_standard_json","title":"compile_solidity_standard_json","text":"<pre><code>def compile_solidity_standard_json(input_json: Dict, **kwargs)\n</code></pre> <p>Compiles the given standard json and adds the resulting metadata of all contracts to the registry.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#compile_vyper_string","title":"compile_vyper_string","text":"<pre><code>def compile_vyper_string(source: str, file_name: Union[Path, str], **kwargs)\n</code></pre> <p>Compiles the given vyper source code and adds the resulting metadata of all contracts to the registry.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#compile_vyper_sources_dict","title":"compile_vyper_sources_dict","text":"<pre><code>def compile_vyper_sources_dict(sources: Dict[str, str], **kwargs)\n</code></pre> <p>Compiles the given vyper source dict <code>'sources'</code> in the input json and adds the resulting metadata of all contracts to the registry.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#compile_contracts_from_vyper_files","title":"compile_contracts_from_vyper_files","text":"<pre><code>def compile_contracts_from_vyper_files(files: List[Union[str, Path]],\n                                       **kwargs)\n</code></pre> <p>Compiles the given files and adds the resulting metadata of all contracts to the registry.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#compile_vyper_standard_json","title":"compile_vyper_standard_json","text":"<pre><code>def compile_vyper_standard_json(input_json: Dict, **kwargs)\n</code></pre> <p>Compiles the given standard json and adds the resulting metadata of all contracts to the registry.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#__getitem__","title":"__getitem__","text":"<pre><code>def __getitem__(key: Union[str, Tuple[str, str]]) -&gt; ContractMetadata\n</code></pre> <p>Retrieve a contract's metadata either by <code>name</code> or by <code>(file_name, contract_name)</code>.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#__contains__","title":"__contains__","text":"<pre><code>def __contains__(key: Union[str, Tuple[str, str]]) -&gt; bool\n</code></pre> <p>Check if a contract's metadata is present either by <code>name</code> or by <code>(file_name, contract_name)</code>.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#__iter__","title":"__iter__","text":"<pre><code>def __iter__()\n</code></pre> <p>Iterate over all contracts, yielding the file name, contract name, and metadata for each.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#iter_find","title":"iter_find","text":"<pre><code>def iter_find(predicate) -&gt; Iterator[Tuple[str, str, ContractMetadata]]\n</code></pre> <p>Iterate over all contracts matching <code>predicate</code>, yielding the file name, contract name, and metadata for each.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#find","title":"find","text":"<pre><code>def find(predicate) -&gt; Optional[Tuple[str, str, ContractMetadata]]\n</code></pre> <p>Find the first contract matching <code>predicate</code>, returning the file name, contract name, and metadata.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#iter_find_by_name","title":"iter_find_by_name","text":"<pre><code>def iter_find_by_name(\n        name: str) -&gt; Iterator[Tuple[str, str, ContractMetadata]]\n</code></pre> <p>Iterate over all contracts with the given name, yielding the file name, contract name, and metadata for each.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#find_by_name","title":"find_by_name","text":"<pre><code>def find_by_name(name: str) -&gt; Optional[Tuple[str, str, ContractMetadata]]\n</code></pre> <p>Find the first contract with the given name, returning the file name, contract name, and metadata.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#find_by_filename","title":"find_by_filename","text":"<pre><code>def find_by_filename(\n        filename: str) -&gt; Optional[Tuple[str, str, ContractMetadata]]\n</code></pre> <p>Find the first contract with the given filename, returning the file name, contract name, and metadata.</p> <p></p>"},{"location":"ethpwn/modules/contract_metadata/#all_contracts","title":"all_contracts","text":"<pre><code>def all_contracts()\n</code></pre> <p>Iterate over all contracts, yielding the file name, contract name, and metadata for each.</p>"},{"location":"ethpwn/modules/contract_names/","title":"Contract names","text":""},{"location":"ethpwn/modules/contract_names/#ethpwnethlibcontract_names","title":"ethpwn.ethlib.contract_names","text":""},{"location":"ethpwn/modules/contract_names/#contractnames-objects","title":"ContractNames Objects","text":"<pre><code>class ContractNames()\n</code></pre> <p>AMaps contract addresses to contract names. Serialized to the local configuration directory to ensure persistence across runs. This allows us to remember all contracts we've referred to by name in the past.</p> <p>In the future we plan on having a global name registry shared across all users of ethpwn that users can opt into.</p> <p></p>"},{"location":"ethpwn/modules/contract_names/#register_contract_name","title":"register_contract_name","text":"<pre><code>def register_contract_name(contract_address, contract_name)\n</code></pre> <p>Name the given contract address with the given contract name.</p> <p></p>"},{"location":"ethpwn/modules/contract_names/#get_contract_names","title":"get_contract_names","text":"<pre><code>def get_contract_names(contract_address) -&gt; List[str]\n</code></pre> <p>Get the names registered for a given contract address.</p> <p></p>"},{"location":"ethpwn/modules/contract_names/#get_contract_address","title":"get_contract_address","text":"<pre><code>def get_contract_address(contract_name) -&gt; str\n</code></pre> <p>Get the address of the given contract name.</p> <p></p>"},{"location":"ethpwn/modules/contract_names/#store","title":"store","text":"<pre><code>def store(contract_names_path)\n</code></pre> <p>Store the names to the given JSON file.</p> <p></p>"},{"location":"ethpwn/modules/contract_names/#load","title":"load","text":"<pre><code>@staticmethod\ndef load(contract_names_path) -&gt; 'ContractNames'\n</code></pre> <p>Load the names from the given JSON path.</p> <p></p>"},{"location":"ethpwn/modules/contract_names/#contract_names","title":"contract_names","text":"<pre><code>def contract_names() -&gt; ContractNames\n</code></pre> <p>Get the global contract names. Loads the registry from disk if it is not already loaded.</p> <p></p>"},{"location":"ethpwn/modules/contract_names/#load_or_create_contract_names","title":"load_or_create_contract_names","text":"<pre><code>def load_or_create_contract_names() -&gt; ContractNames\n</code></pre> <p>Load the contract names from disk, or create a new one if it does not exist.</p> <p></p>"},{"location":"ethpwn/modules/contract_names/#register_contract_name_1","title":"register_contract_name","text":"<pre><code>def register_contract_name(address, name)\n</code></pre> <p>Helper function to easily register a contract at a given address. If the contract is already registered, it is updated / merged with the new information.</p> <p></p>"},{"location":"ethpwn/modules/contract_names/#contract_by_name","title":"contract_by_name","text":"<pre><code>def contract_by_name(name)\n</code></pre> <p>Helper function to easily get the address of a contract by name.</p> <p></p>"},{"location":"ethpwn/modules/contract_names/#names_for_contract","title":"names_for_contract","text":"<pre><code>def names_for_contract(address)\n</code></pre> <p>Helper function to easily get the names of a contract by address.</p> <p></p>"},{"location":"ethpwn/modules/contract_names/#name_for_contract","title":"name_for_contract","text":"<pre><code>def label_for_contract(address)\n</code></pre> <p>Helper function to easily get a name of a contract by address.</p>"},{"location":"ethpwn/modules/contract_registry/","title":"ethpwn.ethlib.contract_registry","text":""},{"location":"ethpwn/modules/contract_registry/#ethpwnethlibcontract_registry","title":"ethpwn.ethlib.contract_registry","text":""},{"location":"ethpwn/modules/contract_registry/#best_effort_get_contract_address_and_tx_hash_and_receipt","title":"best_effort_get_contract_address_and_tx_hash_and_receipt","text":"<pre><code>def best_effort_get_contract_address_and_tx_hash_and_receipt(\n        contract_address=None, tx_hash=None, tx_receipt: TxReceipt = None)\n</code></pre> <p>Takes any combination of contract_address, tx_hash, tx_receipt and returns a tuple of (contract_address, tx_hash, tx_receipt)</p> <p>as best as can be found. E.g. with only a contract address we currently have no way of obtaining the <code>tx_hash</code> and <code>tx_receipt</code>. However, with either of the two we can obtain all three.</p> <p>Arguments:</p> <ul> <li><code>contract_address</code>: The address of the contract</li> <li><code>tx_hash</code>: The transaction hash of the transaction that deployed the contract</li> <li><code>tx_receipt</code>: The transaction receipt of the transaction that deployed the contract</li> </ul> <p>Returns:</p> <p>A tuple of (contract_address, tx_hash, tx_receipt)</p> <p></p>"},{"location":"ethpwn/modules/contract_registry/#contractinstance-objects","title":"ContractInstance Objects","text":"<pre><code>class ContractInstance(Serializable)\n</code></pre> <p>Represents a contract that has been deployed to the blockchain. Binds a contract address to its metadata, associated transaction hash and receipt, and the deployment wallet if it was self-deployed by ethpwn (e.g. via <code>deploy</code>).</p> <p></p>"},{"location":"ethpwn/modules/contract_registry/#to_serializable","title":"to_serializable","text":"<pre><code>def to_serializable()\n</code></pre> <p>Returns:</p> <p>A dictionary that can be serialized to JSON</p> <p></p>"},{"location":"ethpwn/modules/contract_registry/#w3","title":"w3","text":"<pre><code>@property\ndef w3()\n</code></pre> <p>Get a web3 contract object for this contract. Automatically has the correct ABI based on the metadata.</p> <p>Returns:</p> <p>The web3 contract object</p> <p></p>"},{"location":"ethpwn/modules/contract_registry/#balance","title":"balance","text":"<pre><code>@property\ndef balance()\n</code></pre> <p>Get the balance of this contract.</p> <p></p>"},{"location":"ethpwn/modules/contract_registry/#merge","title":"merge","text":"<pre><code>def merge(other: 'ContractInstance') -&gt; bool\n</code></pre> <p>Merge the given contract into this contract. Ensures changes are compatible, e.g. if the address is already set, it cannot be changed. Information can only be added. See <code>update()</code> for more details.</p> <p></p>"},{"location":"ethpwn/modules/contract_registry/#update","title":"update","text":"<pre><code>def update(address=None,\n           metadata=None,\n           deploy_tx_hash=None,\n           deploy_tx_receipt=None,\n           deploy_wallet=None) -&gt; bool\n</code></pre> <p>Update this contract with the given values. If a value is None, it is left unchanged. Ensures changes are compatible,</p> <p>e.g. if the address is already set, it cannot be changed. Information can only be added.</p> <p>Arguments:</p> <ul> <li><code>address</code>: The address of the contract</li> <li><code>metadata</code>: The metadata of the contract</li> <li><code>deploy_tx_hash</code>: The transaction hash of the transaction that deployed the contract</li> <li><code>deploy_tx_receipt</code>: The transaction receipt of the transaction that deployed the contract</li> <li><code>deploy_wallet</code>: The wallet that deployed the contract</li> </ul> <p>Returns:</p> <p>True if any value was changed, False otherwise</p> <p></p>"},{"location":"ethpwn/modules/contract_registry/#contractregistry-objects","title":"ContractRegistry Objects","text":"<pre><code>class ContractRegistry()\n</code></pre> <p>A registry of contracts. Maps contract addresses to contract objects which hold metadata, transaction hash and receipt, and the deployment wallet of each contract (if self-deployed by ethpwn (e.g. via <code>deploy</code>).</p> <p>Serialized to the local configuration directory to ensure persistence across runs. This allows us to remember contracts we've deployed in the past, and also to remember contracts we've interacted with in the past (e.g. via <code>call</code>, <code>transact</code> or seen in <code>ethdbg</code>).</p> <p>In the future we plan on having a global contract registry that is shared across all users of ethpwn that users can opt into. This will allows us to collect a superset of verified contracts that can be used to automatically populate the local contract registry if the user did not have them available locally.</p> <p></p>"},{"location":"ethpwn/modules/contract_registry/#register_contract_metadata","title":"register_contract_metadata","text":"<pre><code>def register_contract_metadata(metadata: 'ContractMetadata',\n                               address=None,\n                               deploy_tx_hash=None,\n                               deploy_tx_receipt: TxReceipt = None,\n                               deploy_wallet=None) -&gt; ContractInstance\n</code></pre> <p>Add information about a deployed contract to the registry. If the contract is already registered, it is updated / merged with the new information.</p> <p>If a contract is newly registered, the registry is automatically saved back to disk.</p> <p></p>"},{"location":"ethpwn/modules/contract_registry/#__contains__","title":"__contains__","text":"<pre><code>def __contains__(contract_address) -&gt; bool\n</code></pre> <p>Check if the given contract address has registered metadata available in the registry.</p> <p>Arguments:</p> <ul> <li><code>contract_address</code>: The address of the contract</li> </ul> <p></p>"},{"location":"ethpwn/modules/contract_registry/#__getitem__","title":"__getitem__","text":"<pre><code>def __getitem__(contract_address) -&gt; ContractInstance\n</code></pre> <p>Get the registered metadata for the given contract address (if any). Throws an exception if no metadata is registered for the given contract address.</p> <p></p>"},{"location":"ethpwn/modules/contract_registry/#get","title":"get","text":"<pre><code>def get(contract_address, default=None) -&gt; ContractInstance\n</code></pre> <p>Get the registered metadata for the given contract address (if any). Returns the given default value if no metadata is registered for the given contract address.</p> <p></p>"},{"location":"ethpwn/modules/contract_registry/#__iter__","title":"__iter__","text":"<pre><code>def __iter__() -&gt; Iterator[Tuple[HexBytes, ContractInstance]]\n</code></pre> <p>Iterate over all registered contracts. Yields tuples of (contract_address, contract).</p> <p></p>"},{"location":"ethpwn/modules/contract_registry/#store","title":"store","text":"<pre><code>def store()\n</code></pre> <p>Store the registry to the given directory. Creates the directory if it does not exist. Stores each contract metadata to <code>contract_registry_dir/&lt;address&gt;.json</code>.</p> <p></p>"},{"location":"ethpwn/modules/contract_registry/#reload_contract","title":"reload_contract","text":"<pre><code>def reload_contract(contract_address) -&gt; 'ContractInstance'\n</code></pre> <p>Load a contract from <code>contract_registry_dir/&lt;address&gt;.{msgpack,json}</code>.</p> <p></p>"},{"location":"ethpwn/modules/contract_registry/#contract_registry","title":"contract_registry","text":"<pre><code>def contract_registry() -&gt; ContractRegistry\n</code></pre> <p>Get the global contract registry. Loads the registry from disk if it is not already loaded.</p> <p></p>"},{"location":"ethpwn/modules/contract_registry/#load_or_create_contract_registry","title":"load_or_create_contract_registry","text":"<pre><code>def load_or_create_contract_registry() -&gt; ContractRegistry\n</code></pre> <p>Load the contract registry from disk if it exists, or create a new one if it does not exist.</p> <p></p>"},{"location":"ethpwn/modules/contract_registry/#register_deployed_contract","title":"register_deployed_contract","text":"<pre><code>def register_deployed_contract(\n        metadata,\n        address=None,\n        deploy_tx_hash=None,\n        deploy_tx_receipt: TxReceipt = None) -&gt; ContractInstance\n</code></pre> <p>Helper function to easily register a deployed contract. If the contract is already registered, it is updated / merged with the new information.</p> <p></p>"},{"location":"ethpwn/modules/contract_registry/#register_contract_at_address","title":"register_contract_at_address","text":"<pre><code>def register_contract_at_address(metadata, address) -&gt; ContractInstance\n</code></pre> <p>Helper function to easily register a contract at a given address. If the contract is already registered, it is updated / merged with the new information.</p> <p></p>"},{"location":"ethpwn/modules/contract_registry/#decode_function_input","title":"decode_function_input","text":"<pre><code>def decode_function_input(contract_address, input, guess=False)\n</code></pre> <p>Decode the given function input for the given contract address. If the contract is registered in the contract registry, the correct metadata is used to decode the input. Otherwise, if <code>guess=True</code>, the input is decoded using the metadata of all known contracts, and the best guess is returned.</p>"},{"location":"ethpwn/modules/currency_utils/","title":"ethpwn.ethlib.currency_utils","text":""},{"location":"ethpwn/modules/currency_utils/#ethpwnethlibcurrency_utils","title":"ethpwn.ethlib.currency_utils","text":"<p>Utilities for dealing with the different units of currency in the Ethereum ecosystem.</p> <p></p>"},{"location":"ethpwn/modules/currency_utils/#parse_wei","title":"parse_wei","text":"<pre><code>def parse_wei(value_string)\n</code></pre> <p>Parse a string representing into a wei value. The string can be in ether, gwei, or wei. If no unit is specified, it is assumed to be wei.</p> <p></p>"},{"location":"ethpwn/modules/currency_utils/#wei","title":"wei","text":"<pre><code>def wei(ether=None, gwei=None, wei=None)\n</code></pre> <p>Convert some amount of ether, gwei, and/or wei to wei. Returns the sum of all values so you can do <code>wei(ether=1, gwei=1)</code> to get 1 ether and 1 gwei in wei.</p> <p></p>"},{"location":"ethpwn/modules/currency_utils/#ether","title":"ether","text":"<pre><code>def ether(wei)\n</code></pre> <p>Convert wei to ether</p> <p></p>"},{"location":"ethpwn/modules/currency_utils/#gwei","title":"gwei","text":"<pre><code>def gwei(wei)\n</code></pre> <p>Convert wei to gwei</p>"},{"location":"ethpwn/modules/evm/","title":"Table of Contents","text":"<ul> <li>ethpwn.ethlib.evm</li> </ul>"},{"location":"ethpwn/modules/evm/#ethpwnethlibevm","title":"ethpwn.ethlib.evm","text":""},{"location":"ethpwn/modules/evm_analyzer/","title":"ethpwn.ethlib.evm_analyzer","text":""},{"location":"ethpwn/modules/evm_analyzer/#ethpwnethlibevm_analyzer","title":"ethpwn.ethlib.evm_analyzer","text":""},{"location":"ethpwn/modules/evm_analyzer/#get_evm_at_block","title":"get_evm_at_block","text":"<pre><code>def get_evm_at_block(block_number: int, **kwargs) -&gt; EVMAnalyzer\n</code></pre> <p>Return an EVMAnalyzer instance for the given block number.</p> <p></p>"},{"location":"ethpwn/modules/evm_analyzer/#get_evm_at_txn","title":"get_evm_at_txn","text":"<pre><code>def get_evm_at_txn(txn: str) -&gt; EVMAnalyzer\n</code></pre> <p>Return an EVMAnalyzer instance for the given transaction hash.</p>"},{"location":"ethpwn/modules/global_context/","title":"ethpwn.ethlib.global_context","text":""},{"location":"ethpwn/modules/global_context/#ethpwnethlibglobal_context","title":"ethpwn.ethlib.global_context","text":"<p>Global context accessible from anywhere in the ethpwn package.</p> <p></p>"},{"location":"ethpwn/modules/global_context/#web3context-objects","title":"Web3Context Objects","text":"<pre><code>class Web3Context()\n</code></pre> <p>A context holding global state used by ethpwn.</p> <p></p>"},{"location":"ethpwn/modules/global_context/#try_auto_connect","title":"try_auto_connect","text":"<pre><code>def try_auto_connect()\n</code></pre> <p>Try to auto connect to a node if the default network is set and autoconnect is not disabled.</p> <p></p>"},{"location":"ethpwn/modules/global_context/#terminal","title":"terminal","text":"<pre><code>@property\ndef terminal()\n</code></pre> <p>Get the terminal</p> <p></p>"},{"location":"ethpwn/modules/global_context/#terminal_1","title":"terminal","text":"<pre><code>@terminal.setter\ndef terminal(value)\n</code></pre> <p>Set the terminal</p> <p></p>"},{"location":"ethpwn/modules/global_context/#network","title":"network","text":"<pre><code>@property\ndef network()\n</code></pre> <p>Get the default network</p> <p></p>"},{"location":"ethpwn/modules/global_context/#network_1","title":"network","text":"<pre><code>@network.setter\ndef network(value)\n</code></pre> <p>Set the default network</p> <p></p>"},{"location":"ethpwn/modules/global_context/#debug_transaction_errors","title":"debug_transaction_errors","text":"<pre><code>@property\ndef debug_transaction_errors()\n</code></pre> <p>Get whether to debug on revert</p> <p></p>"},{"location":"ethpwn/modules/global_context/#debug_transaction_errors_1","title":"debug_transaction_errors","text":"<pre><code>@debug_transaction_errors.setter\ndef debug_transaction_errors(value)\n</code></pre> <p>Set whether to debug on revert</p> <p></p>"},{"location":"ethpwn/modules/global_context/#default_from_addr","title":"default_from_addr","text":"<pre><code>@property\ndef default_from_addr()\n</code></pre> <p>Get the default from address as set or via the default wallet</p> <p></p>"},{"location":"ethpwn/modules/global_context/#default_signing_key","title":"default_signing_key","text":"<pre><code>@property\ndef default_signing_key()\n</code></pre> <p>Get the default signing key</p> <p></p>"},{"location":"ethpwn/modules/global_context/#etherscan_api_key","title":"etherscan_api_key","text":"<pre><code>@property\ndef etherscan_api_key()\n</code></pre> <p>Get the etherscan API key</p> <p></p>"},{"location":"ethpwn/modules/global_context/#log_level","title":"log_level","text":"<pre><code>@property\ndef log_level()\n</code></pre> <p>Get the log level of the logger</p> <p></p>"},{"location":"ethpwn/modules/global_context/#connect","title":"connect","text":"<pre><code>def connect(url, can_fail=False, **kwargs)\n</code></pre> <p>Connect to the Ethereum node at <code>url</code> via HTTP/HTTPS, Websocket, or IPC depending on the URL scheme. If <code>can_fail</code> is True, then the function will return False if it fails to connect instead of raising an exception.</p> <p></p>"},{"location":"ethpwn/modules/global_context/#connect_http","title":"connect_http","text":"<pre><code>def connect_http(url, can_fail=False, **kwargs)\n</code></pre> <p>Connect to a remote Ethereum node via HTTP/HTTPS</p> <p></p>"},{"location":"ethpwn/modules/global_context/#connect_ipc","title":"connect_ipc","text":"<pre><code>def connect_ipc(path='/home/eth/.ethereum/geth.ipc', can_fail=False)\n</code></pre> <p>Connect to a local Ethereum node via IPC</p> <p></p>"},{"location":"ethpwn/modules/global_context/#connect_websocket","title":"connect_websocket","text":"<pre><code>def connect_websocket(url, can_fail=False, **kwargs)\n</code></pre> <p>Connect to an Ethereum node via WebSockets</p> <p></p>"},{"location":"ethpwn/modules/global_context/#pessimistic_gas_price_estimate","title":"pessimistic_gas_price_estimate","text":"<pre><code>def pessimistic_gas_price_estimate()\n</code></pre> <p>Estimate the gas price for a transaction. This is a pessimistic estimate that will overestimate the gas price by a factor of 2. This should be good enough to mostly ensure that the transaction will be mined in a reasonable amount of time.</p> <p></p>"},{"location":"ethpwn/modules/global_context/#pessimistic_transaction_cost","title":"pessimistic_transaction_cost","text":"<pre><code>def pessimistic_transaction_cost(gas_used_estimate)\n</code></pre> <p>Estimate the cost of a transaction. This is a pessimistic estimate that will overestimate the gas price by a factor of 2. This should be good enough to mostly ensure that the transaction will be mined in a reasonable amount of time.</p> <p></p>"},{"location":"ethpwn/modules/global_context/#with_local_context","title":"with_local_context","text":"<pre><code>@contextlib.contextmanager\ndef with_local_context(**kwargs)\n</code></pre> <p>Temporarily set the global context to a new context. Will restore the old context when the context manager exits.</p>"},{"location":"ethpwn/modules/hashes/","title":"ethpwn.ethlib.hashes","text":""},{"location":"ethpwn/modules/hashes/#ethpwnethlibhashes","title":"ethpwn.ethlib.hashes","text":""},{"location":"ethpwn/modules/hashes/#keccak256","title":"keccak256","text":"<pre><code>def keccak256(plaintext)\n</code></pre> <p>Computes the keccak256 hash of a plaintext string.</p> <p></p>"},{"location":"ethpwn/modules/hashes/#signature_hash","title":"signature_hash","text":"<pre><code>def signature_hash(plaintext)\n</code></pre> <p>Computes the signature hash of a plaintext string.</p> <p></p>"},{"location":"ethpwn/modules/hashes/#register_signature_hash","title":"register_signature_hash","text":"<pre><code>def register_signature_hash(value, hash)\n</code></pre> <p>Register a signature hash and its given pre-image (plaintext) in the global hash table.</p> <p></p>"},{"location":"ethpwn/modules/hashes/#lookup_signature_hash_local","title":"lookup_signature_hash_local","text":"<pre><code>def lookup_signature_hash_local(hash)\n</code></pre> <p>Look up a signature hash locally in the current global hash table.</p> <p></p>"},{"location":"ethpwn/modules/hashes/#lookup_signature_hash_database","title":"lookup_signature_hash_database","text":"<pre><code>def lookup_signature_hash_database(hash)\n</code></pre> <p>Look up a signature hash in the 4byte.directory database.</p> <p></p>"},{"location":"ethpwn/modules/hashes/#lookup_signature_hash","title":"lookup_signature_hash","text":"<pre><code>def lookup_signature_hash(hash)\n</code></pre> <p>Look up a signature hash in the global hash table. If it is not found, look it up in the 4byte.directory database and register it in the global hash table.</p>"},{"location":"ethpwn/modules/prelude/","title":"Prelude","text":""},{"location":"ethpwn/modules/prelude/#ethpwnethlibprelude","title":"ethpwn.ethlib.prelude","text":""},{"location":"ethpwn/modules/python_introspection_utils/","title":"Python introspection utils","text":""},{"location":"ethpwn/modules/python_introspection_utils/#ethpwnethlibpython_introspection_utils","title":"ethpwn.ethlib.python_introspection_utils","text":""},{"location":"ethpwn/modules/serialization_utils/","title":"ethpwn.ethlib.serialization_utils","text":""},{"location":"ethpwn/modules/serialization_utils/#ethpwnethlibserialization_utils","title":"ethpwn.ethlib.serialization_utils","text":""},{"location":"ethpwn/modules/serialization_utils/#serializable-objects","title":"Serializable Objects","text":"<pre><code>class Serializable(abc.ABC)\n</code></pre> <p>A class that can be serialized to JSON and deserialized from JSON.</p> <p></p>"},{"location":"ethpwn/modules/serialization_utils/#register_serializable","title":"register_serializable","text":"<pre><code>def register_serializable(cls)\n</code></pre> <p>Register a class as serializable. This is done automatically when a class inherits from Serializable.</p> <p></p>"},{"location":"ethpwn/modules/serialization_utils/#decoder_object_hook","title":"decoder_object_hook","text":"<pre><code>def decoder_object_hook(obj)\n</code></pre> <p>A custom JSON decoder object_hook that can handle AttributeDict, HexBytes and Serializable objects.</p> <p></p>"},{"location":"ethpwn/modules/serialization_utils/#deserialize_from_file","title":"deserialize_from_file","text":"<pre><code>def deserialize_from_file(path=None, encoding=None)\n</code></pre> <p>Deserialize a file to a Python object using the custom decoder.</p> <p></p>"},{"location":"ethpwn/modules/serialization_utils/#deserialize_from_bytes","title":"deserialize_from_bytes","text":"<pre><code>def deserialize_from_bytes(s, encoding=None)\n</code></pre> <p>Deserialize bytes to a Python object using the custom decoder.</p> <p></p>"},{"location":"ethpwn/modules/serialization_utils/#serialize_to_file","title":"serialize_to_file","text":"<pre><code>def serialize_to_file(obj, path, encoding=None)\n</code></pre> <p>Serialize a Python object to a file using the custom encoder and a given encoding scheme.</p> <p>Arguments:</p> <ul> <li><code>obj</code>: the object to serialize</li> <li><code>path</code>: the path to the file to write to (not including the suffix)</li> <li><code>encoding</code>: the encoding scheme to use (e.g. 'json', 'msgpack')</li> </ul> <p></p>"},{"location":"ethpwn/modules/serialization_utils/#serialize_to_bytes","title":"serialize_to_bytes","text":"<pre><code>def serialize_to_bytes(obj, encoding=None)\n</code></pre> <p>Serialize a Python object to a JSON string using the custom encoder.</p>"},{"location":"ethpwn/modules/transactions/","title":"ethpwn.ethlib.transactions","text":""},{"location":"ethpwn/modules/transactions/#ethpwnethlibtransactions","title":"ethpwn.ethlib.transactions","text":""},{"location":"ethpwn/modules/transactions/#insufficientfundserror-objects","title":"InsufficientFundsError Objects","text":"<pre><code>class InsufficientFundsError(Exception)\n</code></pre> <p>An exception that is raised when a transaction fails due to insufficient funds.</p> <p></p>"},{"location":"ethpwn/modules/transactions/#transactionfailederror-objects","title":"TransactionFailedError Objects","text":"<pre><code>class TransactionFailedError(Exception)\n</code></pre> <p>An exception that is raised when a transaction fails. This is usually due to an uncaught revert or violated assert in the contract.</p> <p></p>"},{"location":"ethpwn/modules/transactions/#encode_transaction","title":"encode_transaction","text":"<pre><code>def encode_transaction(contract_function=None, from_addr=None, **kwargs)\n</code></pre> <p>Encode a transaction to call a <code>contract_function</code> or a raw transaction if <code>contract_function</code> is None.</p> <p></p>"},{"location":"ethpwn/modules/transactions/#transfer_funds","title":"transfer_funds","text":"<pre><code>def transfer_funds(from_addr, to_addr, value=None, **kwargs)\n</code></pre> <p>Transfer funds from <code>from_addr</code> to <code>to_addr</code>. If <code>value</code> is None, transfer all available funds minus the transaction cost.</p> <p></p>"},{"location":"ethpwn/modules/transactions/#debug_simulated_transaction","title":"debug_simulated_transaction","text":"<pre><code>def debug_simulated_transaction(tx)\n</code></pre> <p>Simulate a transaction and attempt to debug the state using <code>ipdb</code> if it fails.</p> <p></p>"},{"location":"ethpwn/modules/transactions/#debug_onchain_transaction","title":"debug_onchain_transaction","text":"<pre><code>def debug_onchain_transaction(tx_hash)\n</code></pre> <p>Simulate a transaction and attempt to debug the state using <code>ipdb</code> if it fails.</p> <p>TODO: we would like this to automatically set up <code>ethdbg</code> to debug the transaction failure if requested.</p> <p></p>"},{"location":"ethpwn/modules/transactions/#transact","title":"transact","text":"<pre><code>def transact(contract_function=None,\n             private_key=None,\n             force=False,\n             wait_for_receipt=True,\n             from_addr=None,\n             retry=3,\n             debug_transaction_errors=None,\n             **tx) -&gt; (HexBytes, TxReceipt)\n</code></pre> <p>Send a transaction to the blockchain. If <code>contract_function</code> is not None, call the contract function.</p> <p>If <code>private_key</code> is None, use the default signing key from the global context. If <code>from_addr</code> is None, use the default from address from the global context. If <code>wait_for_receipt</code> is True, wait for the transaction receipt and return it. If <code>force</code> is True, ignore simulated errors and push the transaction to the blockchain depite the likely revert.</p> <p></p>"},{"location":"ethpwn/modules/transactions/#deploy_bare_contract","title":"deploy_bare_contract","text":"<pre><code>def deploy_bare_contract(bin, metadata=None, **tx_kwargs)\n</code></pre> <p>Deploy a contract with the given constructor bytecode. If <code>metadata</code> is not None, use the ABI from the metadata to create a contract object.</p> <p></p>"},{"location":"ethpwn/modules/transactions/#deploy_shellcode_contract","title":"deploy_shellcode_contract","text":"<pre><code>def deploy_shellcode_contract(shellcode, **tx_kwargs)\n</code></pre> <p>Deploy a contract with the given shellcode. This will create a shellcode deployer constructor that will deploy the given shellcode when called.</p>"},{"location":"ethpwn/modules/user_input/","title":"User input","text":""},{"location":"ethpwn/modules/user_input/#ethpwnethlibuser_input","title":"ethpwn.ethlib.user_input","text":""},{"location":"ethpwn/modules/utils/","title":"ethpwn.ethlib.utils","text":""},{"location":"ethpwn/modules/utils/#ethpwnethlibutils","title":"ethpwn.ethlib.utils","text":""},{"location":"ethpwn/modules/utils/#normalize_contract_address","title":"normalize_contract_address","text":"<pre><code>@functools.lru_cache(maxsize=1024)\ndef normalize_contract_address(address_or_label, resolve_labels=True) -&gt; str\n</code></pre> <p>Normalize a contract address. This ensures all addresses are checksummed and have the 0x prefix.</p> <p></p>"},{"location":"ethpwn/modules/utils/#get_shared_prefix_len","title":"get_shared_prefix_len","text":"<pre><code>def get_shared_prefix_len(a, b)\n</code></pre> <p>Get the length of the shared prefix of two strings.</p> <p></p>"},{"location":"ethpwn/modules/utils/#to_snake_case","title":"to_snake_case","text":"<pre><code>def to_snake_case(s: str) -&gt; str\n</code></pre> <p>Convert a string to snake case.</p> <p></p>"},{"location":"ethpwn/modules/utils/#show_diff","title":"show_diff","text":"<pre><code>def show_diff(a, b, show_old_new=False)\n</code></pre> <p>Show a nice <code>rich</code> table of the diff between two objects using <code>deepdiff</code>.</p> <p></p>"},{"location":"ethpwn/modules/utils/#get_chainid","title":"get_chainid","text":"<pre><code>def get_chainid(chain_name)\n</code></pre> <p>Get the chain id for a given chain name.</p> <p></p>"},{"location":"ethpwn/modules/utils/#get_chain_name","title":"get_chain_name","text":"<pre><code>def get_chain_name(id)\n</code></pre> <p>Get the chain name for a given chain id.</p> <p></p>"},{"location":"ethpwn/modules/utils/#which","title":"which","text":"<pre><code>def which(name, all=False, path=None)\n</code></pre> <p>which(name, flags = os.X_OK, all = False) -&gt; str or str set</p> <p>Works as the system command <code>which</code>; searches $PATH for <code>name</code> and returns a full path if found.</p> <p>If <code>all</code> is :const:<code>True</code> the set of all found locations is returned, else the first occurrence or :const:<code>None</code> is returned.</p> <p>Arguments:</p> <ul> <li><code>name</code> str - The file to search for.</li> <li><code>all</code> bool - Whether to return all locations where <code>name</code> was found.</li> </ul> <p>Returns:</p> <p>If <code>all</code> is :const:<code>True</code> the set of all locations where <code>name</code> was found,   else the first location or :const:<code>None</code> if not found.</p> <p>Example:</p> <p>which('sh') # doctest: +ELLIPSIS   '.../bin/sh'</p> <p></p>"},{"location":"ethpwn/modules/utils/#run_in_new_terminal","title":"run_in_new_terminal","text":"<pre><code>def run_in_new_terminal(command,\n                        terminal=None,\n                        args=None,\n                        kill_at_exit=True,\n                        preexec_fn=None)\n</code></pre> <p>run_in_new_terminal(command, terminal=None, args=None, kill_at_exit=True, preexec_fn=None) -&gt; int</p> <p>Run a command in a new terminal.</p> <p>When <code>terminal</code> is not set: - If <code>context.terminal</code> is set it will be used. If it is an iterable then <code>context.terminal[1:]</code> are default arguments. - If a <code>pwntools-terminal</code> command exists in <code>$PATH</code>, it is used - If tmux is detected (by the presence of the <code>$TMUX</code> environment variable), a new pane will be opened. - If GNU Screen is detected (by the presence of the <code>$STY</code> environment variable), a new screen will be opened. - If <code>$TERM_PROGRAM</code> is set, that is used. - If X11 is detected (by the presence of the <code>$DISPLAY</code> environment variable), <code>x-terminal-emulator</code> is used. - If KDE Konsole is detected (by the presence of the <code>$KONSOLE_VERSION</code> environment variable), a terminal will be split. - If WSL (Windows Subsystem for Linux) is detected (by the presence of a <code>wsl.exe</code> binary in the <code>$PATH</code> and <code>/proc/sys/kernel/osrelease</code> containing <code>Microsoft</code>), a new <code>cmd.exe</code> window will be opened.</p> <p>If <code>kill_at_exit</code> is :const:<code>True</code>, try to close the command/terminal when the current process exits. This may not work for all terminal types.</p> <p>Arguments:</p> <ul> <li><code>command</code> str - The command to run.</li> <li><code>terminal</code> str - Which terminal to use.</li> <li><code>args</code> list - Arguments to pass to the terminal</li> <li><code>kill_at_exit</code> bool - Whether to close the command/terminal on process exit.</li> <li><code>preexec_fn</code> callable - Callable to invoke before exec().</li> </ul> <p>Notes:</p> <p>The command is opened with <code>/dev/null</code> for stdin, stdout, stderr.</p> <p>Returns:</p> <p>PID of the new terminal process</p>"}]}